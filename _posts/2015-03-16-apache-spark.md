---
layout: post
title: Apache Spark
date: 2015-03-17
categories: [computer science]
tags: [computer networks]

---

## High-Speed In-memory Computing for Big Data Applications

Apache Hadoop은 매우 낮은 코스트로 방대한 양의 데이터를 저장하고 처리
할 수 있도록 하여 빅데이터 처리에 혁명을 가져 왔습니다. MapReduce가
시스템 로그 분석부터 ETL 실행, Web 인덱스 작성, 개인 추천 시스템의 실행
기반에 이르기까지 복잡한 배치 어플리케이션을 구현하기 위한 이상적인
플랫폼이라는 것은 이미 증명 되었습니다. 하지만, 내장애성과 단일 패스
계산 모델을 제공하기 위해 영속적 스토리지에 의존 하는 점 때문에,
MapReduce는 로우 레이턴시(저 지연)의 어플리케이션이나 기계학습, 그래프
알고리즘 등에서 사용하는 반복적인 계산 처리에는 적합하지 않습니다. 


 Apache Spark는 성능과 편의성을 극적으로 향상시키면서, MapReduce의 계산
모델을 일반화 하여 이러한 제한 사항들에 대처 하고 있습니다.

 

## Spark로 신속, 간단하게 빅데이터 처리

 

 기본적으로 Spark는 Mapper, Reducer, JOIN, GROUP BY, 필터 등의 임의의
연산자에 의해 어플리케이션을 쓸 수 있도록 하는 프로그래밍 모델입니다. 이
조합에 의해 반복되는 기계학습, 스트리밍, 복잡한 쿼리, 배치 등 넓은
영역을 간단히 표현 할 수 있습니다.

 

 또 Spark는 연산자 각각이 생성하는 데이터를 추적하여 어플리케이션이
확실히 메모리 내에 이 데이터를 보존 할 수 있게 합니다. 이로
인해 어플리케이션은 높은 코스트의 디스크 접근을 피할 수 있기 때문에, 이
점이 Spark 성능의 키 포인트라 할 수 있습니다. 아래 그림에 나타나는 바와
같이 이 기능에 의해 아래 항목들이 가능하게 됩니다.



 ・ 메모리내 작업 데이터셋을 캐시하여, 메모리 속도로 계산을
실행함으로써 로우 레이턴시 계산

 ・ 뒤에 따르는 반복 처리의 공유 데이터를 메모리상에 유지 하거나,
반복하여 같은 데이터셋으로 접근함에 따른 효율적인 반복 알고리즘

 

![](http://cfile3.uf.tistory.com/image/210E785053396DB513A11F)

 

 Spark의 사용 편의성은 유저가 많은 Map과 Reduce 처리에 매이지 않고
어플리케이션을 구축할 수 있다는 일반적인 프로그래밍 모델로부터 유래
합니다. Spark의 병렬 프로그램은 순차 프로그램과 매우 닮아 있어, 그에
따라 개발과 리뷰를 간단히 할 수 있습니다. 마지막으로 Spark에 의해 유저는
단일 어플리케이션으로 배치 처리, 인터랙티브 처리, 스트리밍 잡을 간단하게
구성 할 수 있습니다. 그 결과, Spark 잡은 Hadoop 잡에 비해 1/2 부터
1/10의 코드 양으로 최대 100배까지의 속도로 실행 할 수 있습니다.


## 고도 데이터 분석과 데이터 사이언스를 위한 Spark 이용
 

## 인터랙티브한 데이터 분석

 

 Spark의 가장 편리한 기능 중 하나는 인터랙티브(대화형) 쉘 입니다.
이것으로 유저는 바로 Spark 성능을 시험 해 볼 수 있습니다. IDE도 코드
컴파일도 필요 없습니다. 쉘은 데이터를 인터랙티브하게 탐색하거나, 개발
중의 어플리케이션 중 일부를 테스트 하기 위한 주요한 툴로 사용
가능합니다.

 

 아래의 스크린샷은 유저가 파일을 로드하고, 'Holiday'를 포함하는 행 수를
카운트하는 Spark Python 쉘을 보여 줍니다.

 

![](http://cfile6.uf.tistory.com/image/27423D4F53396F10276764)

 

 이 예에서 나타나듯이 Spark는 HDFS로부터 데이터를 읽고 쓸 수 있습니다.
이와 같이, Hadoop 이용자는 Spark를 인스톨 하면 바로 HDFS 데이터 분석을
시작 할 수 있습니다. 그리고, 메모리 내의 데이터셋을 캐시 해서 유저가
대화식으로 여러 종류의 복잡한 계산을 실행 할 수 있습니다!


 Spark는 스탠드얼론 어플리케이션을 위한 Scala 쉘 및 Java, Scala,
Python으로 API를 제공 합니다.


## 보다 빠른 배치

 

 Spark 초기 구현 중에는 기존의 MapReduce 어플리케이션의 성능을 개선 할
방법에 초점을 맞춘 것도 있었습니다. MapReduce는 실제로는 범용적인 처리
플레임 워크로, 코어 Hadoop에서 가장 잘 알려진 구현에만 한하는 것은
아니라는것을 기억 해 주세요. Spark도 MapReduce를 제공하며 Spark는
메모리를 효율 좋게 쓸 수 있기 때문에 (필요하다면 장애를 복구하기 위한
계통을 사용한다고 해도), 반복 처리 프로그램에서 캐시를 쓰지 않아도
Spark의 MapReduce 구현 중 몇 가지는 Hadoop의 MapReduce와 비교해서 정말
빠릅니다.


 아래 예는 MapReduce의 가장 유명한 예인 워드 카운트의 Spark 구현을
보여줍니다. 여기서 Spark는 연산자 체인을 지원하고 있는 것을 알 수
있습니다. 이것은 데이터 필터링을 복잡한 MapReduce 잡 실행 전에 행하는
등, 데이터 전처리나 후처리를 행할 때 매우 편리합니다.

 

![](http://cfile21.uf.tistory.com/image/2778CC465339736133F74F)

 

 

 Spark의 배치 처리 능력은 현실 세계의 시나리오에서 증명 되었습니다. 한
매우 거대한 실리콘 벨리의 인터넷 기업은 모델의 트레이닝 파이프라인에
있어서 특징량 추출을 구현한 하나의 MR 잡을 그대로 이식한 것 만으로 3배의
속도 개선을 꾀할 수 있었습니다.


## 반복 알고리즘

![](http://cfile8.uf.tistory.com/image/2127ED42533973F10C01A0)

 

 Spark는 유저나 어플리케이션이 명시적으로 cache() 오퍼레이션을 호출 하는
것으로 데이터 셋을 캐시 할 수 있습니다. 이것은 어플리케이션이 디스크가
아닌, RAM에서 데이터로 접근 할 수 있다는 것을 의미 하는 것으로, 이에
따라 같은 데이터셋에 반복해서 접근하는 반복 알고리즘 성능을 극적으로
개선 할 수 있습니다. 모든 기계학습과 그래프 알고리즘은 본질적으로
반복적이도록, 이 유즈케이스는 어플리케이션의 중요한 영역을 커버 하고
있습니다.

 

 

 세계 최대급의 인터넷 기업 두 곳이 광고 타겟팅과 컨텐츠 추천을 제공하기
위해 Spark의 효율적인 반복 실행을 활용하고 있습니다. 로지스틱 회귀와
같은 기계학습 알고리즘은 기존 Hadoop 기반의 구현과 비교하여 100배 빠르게
실행 할 수 있습니다. (오른쪽 그림을 봐 주세요). 한편 협조 필터링이나
ADMM(alternating direction method of multipliers) 과 같은 알고리즘에서는
15배 고속화에 머물렀습니다.

 

 

 아래의 예는 다차원 특징 공간내의 점의 두 부분을 분리하는 가장 좋은
초평면을 찾아내기 위해 로지스틱 회귀를 사용하고 있습니다. MapReduce 중
각 이터레이션에서는 디스크로부터 데이터를 읽어 들여 거대한 오버헤드가
발생하는 한편, Spark에서는 캐시된 데이터 셋을 'points'가 메모리로부터
반복 접근 하고 있는 점에 주의 해 주세요.

 

![](http://cfile22.uf.tistory.com/image/222E8144533976522CE944)

 

## 실시간 스트림 처리

 

 자유롭게 쓸 수 있는 로우 레이턴시 데이터 분석 시스템이 손에 있을 때, 그
엔진을 라이브 데이터 스트림 처리로 확장하는 것은 당연한 일입니다.
Spark에는 스트림 조작을 위한 API가 있어 정확히 한 번 뿐인 시멘틱과
stateful(상태유지) 연산자의 완전 복구를 제공합니다. 스트림 처리에 같은
Spark API를 제공하고 있어 보통의 Spark 어플리케이션 코드를 재이용 할 수
있다는 명확한 이점도 있습니다.


 아래의 코드는 해쉬태그로 시작하는 단어의 워드 카운트를 10초마다
데이터에 대해 필터 처리하도록 하는 심플한 네트워크 스트림 처리 잡을 보여
주고 있습니다. 전의 워드 카운트 예와 비교 해 보면 거의 같은 코드가
사용되어 있다는 것을 알 수 있지만 이번에는 라이브 데이터 스트림을
처리하고 있습니다.

 

![](http://cfile22.uf.tistory.com/image/24111541533977EB30559E)

 

 Spark Streaming API가 릴리즈 되고 나서 아직 1년도 지나지 않았지만,
유저는 그 API를 사용한 어플리케이션을 실제 환경에 도입함으로써 시스템
로그를 집약한 stateful 데이터에 대해 감시와 알림을 제공하고, 불과 몇
초의 레이턴시 만으로 매우 빠른 처리를 달성하고 있습니다.

 

## 의사 결정의 신속화

 

 많은 기업은 추천 시스템, 광고 타겟 설정 혹은 예측 분석의 형태로 유저의
의사결정 혹은 의사결정의 촉진을 위해 빅데이터를 사용하고 있습니다. 어떤
의사결정에 있어서든 중요한 요소는 레이턴시입니다. 즉, 입력 데이터가 이용
가능하게 되고 나서부터 의사결정을 실행하기 까지 걸리는 시간을 말합니다.
의사결정의 기다리는 시간을 줄이는 것은 폭넓게 그 유효성을 높여
최종적으로는 기업의 투자대효과(ROI)를 늘릴 수 있습니다. 이런 결정들의
대부분은 (예를 들어 기계학습이나 통계적 알고리즘 등의) 복잡한 계산에
기반하고 있기 때문에 Spark가 의사결정을 스피드업 하기 위해 이상적이라는
것을 알 수 있습니다.


 당연한 얘기겠지만, Spark는 기다리는 시간을 절감하기 위한 것 뿐만 아니라
결정의 질을 향상 시키기 위하여 이용 되고 있습니다. 예를 들면, 광고
타겟팅에서 인터넷 상에서의 영상 전송의 품질을 향상 시키기 까지의 폭넓은
범위에 적용되고 있습니다.

 

## 통일된 파이프라인

 

 오늘날 빅데이터의 대부분은 MapReduce뿐 아니라 스트리밍, 배치,
인터랙티브 처리 플레임워크를 통합함에 따라 전개 되고 있습니다. 많은
시스템을 Spark로 바꿈으로써 유저는 데이터 처리 파이프라인의 복잡함을
극적으로 절감 시킬 수 있습니다.


 예를 들면, 오늘날 많은 기업은 MapReduce를 사용하여 리포트를 생성하고
이력 쿼리에 대해 답하고 별도의 시스템을 구축하여 리얼타임으로 중요한
메트릭스를 추적하기 위한 스트림 처리를 실행 하고 있습니다. 이 방법은
2가지의 다른 계산 모델 어플리케이션을 개발하는 것 뿐 아니라, 2개의 다른
시스템의 유지 관리도 필요로 합니다. 또, 2개의 스택으로 생성되는 결과에
일관성이 있다는 것을 보증할 필요성도 생기겠죠 (예를 들어, 스트리밍
어플리케이션과 MapReduce에 의해 계산된 카운터가 같은지 어떤지).


 최근에는 유저가 이력 리포트를 제공하기 위한 배치 처리 뿐 아니라, 스트림
처리를 구현하기 위해 Spark를 이용하고 있습니다. 이에 따라 디플로이와
보수를 간소화 할 뿐만 아니라, 어플리케이션 개발을 극적으로 심플하게 할
수 있습니다. 같은 코드로 처리하고 있는 것이라면, 리얼타임과 이력
메트릭스의 일관성을 유지 하는 것은 문제가 되지 않습니다. 통일화의 마지막
이점은, 다른 시스템 간에서의 데이터 이동이 불필요 하게 됨에 따른 성능
향상입니다. 일단 메모리 상에 보존 되면 그 데이터는 스트리밍 처리와 이력
(혹은 인터랙티브한) 쿼리 사이에서 공유 할 수 있습니다.
