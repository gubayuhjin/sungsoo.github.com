---
layout: post
title: Compiling CUDA C/C++ with LLVM 
date: 2016-05-17
categories: [computer science]
tags: [gpgpu]

---


# Compiling CUDA C/C++ with LLVM


[http://images.nvidia.com/events/sc15/SC5105-open-source-cuda-compiler.html](http://images.nvidia.com/events/sc15/SC5105-open-source-cuda-compiler.html)

<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id1">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline"></a></h2>
<p>This document contains the user guides and the internals of compiling CUDA
C/C++ with LLVM. It is aimed at both users who want to compile CUDA with LLVM
and developers who want to improve LLVM for GPUs. This document assumes a basic
familiarity with CUDA. Information about CUDA programming can be found in the
<a class="reference external" href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html">CUDA programming guide</a>.</p>
</div>
<div class="section" id="how-to-build-llvm-with-cuda-support">
<h2><a class="toc-backref" href="#id2">How to Build LLVM with CUDA Support</a><a class="headerlink" href="#how-to-build-llvm-with-cuda-support" title="Permalink to this headline"></a></h2>
<p>CUDA support is still in development and works the best in the trunk version
of LLVM. Below is a quick summary of downloading and building the trunk
version. Consult the <a class="reference external" href="http://llvm.org/docs/GettingStarted.html">Getting Started</a> page for more details on setting
up LLVM.</p>
<ol class="arabic">
<li><p class="first">Checkout LLVM</p>
<div class="highlight-console"><div class="highlight"><pre><span class="gp">$</span> <span class="nb">cd </span>where-you-want-llvm-to-live
<span class="gp">$</span> svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm
</pre></div>
</div>
</li>
<li><p class="first">Checkout Clang</p>
<div class="highlight-console"><div class="highlight"><pre><span class="gp">$</span> <span class="nb">cd </span>where-you-want-llvm-to-live
<span class="gp">$</span> <span class="nb">cd </span>llvm/tools
<span class="gp">$</span> svn co http://llvm.org/svn/llvm-project/cfe/trunk clang
</pre></div>
</div>
</li>
<li><p class="first">Configure and build LLVM and Clang</p>
<div class="highlight-console"><div class="highlight"><pre><span class="gp">$</span> <span class="nb">cd </span>where-you-want-llvm-to-live
<span class="gp">$</span> mkdir build
<span class="gp">$</span> <span class="nb">cd </span>build
<span class="gp">$</span> cmake <span class="o">[</span>options<span class="o">]</span> ..
<span class="gp">$</span> make
</pre></div>
</div>
</li>
</ol>
</div>
<div class="section" id="how-to-compile-cuda-c-c-with-llvm">
<h2><a class="toc-backref" href="#id3">How to Compile CUDA C/C++ with LLVM</a><a class="headerlink" href="#how-to-compile-cuda-c-c-with-llvm" title="Permalink to this headline"></a></h2>
<p>We assume you have installed the CUDA driver and runtime. Consult the <a class="reference external" href="https://docs.nvidia.com/cuda/cuda-installation-guide-linux/index.html">NVIDIA
CUDA installation guide</a> if
you have not.</p>
<p>Suppose you want to compile and run the following CUDA program (<tt class="docutils literal"><span class="pre">axpy.cu</span></tt>)
which multiplies a <tt class="docutils literal"><span class="pre">float</span></tt> array by a <tt class="docutils literal"><span class="pre">float</span></tt> scalar (AXPY).</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &lt;iostream&gt;</span>

<span class="n">__global__</span> <span class="kt">void</span> <span class="nf">axpy</span><span class="p">(</span><span class="kt">float</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">y</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">kDataLen</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

  <span class="kt">float</span> <span class="n">a</span> <span class="o">=</span> <span class="mf">2.0f</span><span class="p">;</span>
  <span class="kt">float</span> <span class="n">host_x</span><span class="p">[</span><span class="n">kDataLen</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mf">1.0f</span><span class="p">,</span> <span class="mf">2.0f</span><span class="p">,</span> <span class="mf">3.0f</span><span class="p">,</span> <span class="mf">4.0f</span><span class="p">};</span>
  <span class="kt">float</span> <span class="n">host_y</span><span class="p">[</span><span class="n">kDataLen</span><span class="p">];</span>

  <span class="c1">// Copy input data to device.</span>
  <span class="kt">float</span><span class="o">*</span> <span class="n">device_x</span><span class="p">;</span>
  <span class="kt">float</span><span class="o">*</span> <span class="n">device_y</span><span class="p">;</span>
  <span class="n">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device_x</span><span class="p">,</span> <span class="n">kDataLen</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
  <span class="n">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">device_y</span><span class="p">,</span> <span class="n">kDataLen</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
  <span class="n">cudaMemcpy</span><span class="p">(</span><span class="n">device_x</span><span class="p">,</span> <span class="n">host_x</span><span class="p">,</span> <span class="n">kDataLen</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span>
             <span class="n">cudaMemcpyHostToDevice</span><span class="p">);</span>

  <span class="c1">// Launch the kernel.</span>
  <span class="n">axpy</span><span class="o">&lt;&lt;&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="n">kDataLen</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">device_x</span><span class="p">,</span> <span class="n">device_y</span><span class="p">);</span>

  <span class="c1">// Copy output data to host.</span>
  <span class="n">cudaDeviceSynchronize</span><span class="p">();</span>
  <span class="n">cudaMemcpy</span><span class="p">(</span><span class="n">host_y</span><span class="p">,</span> <span class="n">device_y</span><span class="p">,</span> <span class="n">kDataLen</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">),</span>
             <span class="n">cudaMemcpyDeviceToHost</span><span class="p">);</span>

  <span class="c1">// Print the results.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">kDataLen</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"y["</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">"] = "</span> <span class="o">&lt;&lt;</span> <span class="n">host_y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">cudaDeviceReset</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The command line for compilation is similar to what you would use for C++.</p>
<div class="highlight-console"><div class="highlight"><pre><span class="gp">$</span> clang++ axpy.cu -o axpy --cuda-gpu-arch<span class="o">=</span>&lt;GPU arch&gt;  <span class="se">\</span>
<span class="go">    -L&lt;CUDA install path&gt;/&lt;lib64 or lib&gt;              \</span>
<span class="go">    -lcudart_static -ldl -lrt -pthread</span>
<span class="gp">$</span> ./axpy
<span class="go">y[0] = 2</span>
<span class="go">y[1] = 4</span>
<span class="go">y[2] = 6</span>
<span class="go">y[3] = 8</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">&lt;CUDA</span> <span class="pre">install</span> <span class="pre">path&gt;</span></tt> is the root directory where you installed CUDA SDK,
typically <tt class="docutils literal"><span class="pre">/usr/local/cuda</span></tt>. <tt class="docutils literal"><span class="pre">&lt;GPU</span> <span class="pre">arch&gt;</span></tt> is <a class="reference external" href="https://developer.nvidia.com/cuda-gpus">the compute capability of
your GPU</a>. For example, if you want
to run your program on a GPU with compute capability of 3.5, you should specify
<tt class="docutils literal"><span class="pre">--cuda-gpu-arch=sm_35</span></tt>.</p>
</div>
<div class="section" id="detecting-clang-vs-nvcc">
<h2><a class="toc-backref" href="#id4">Detecting clang vs NVCC</a><a class="headerlink" href="#detecting-clang-vs-nvcc" title="Permalink to this headline"></a></h2>
<p>Although clang’s CUDA implementation is largely compatible with NVCC’s, you may
still want to detect when you’re compiling CUDA code specifically with clang.</p>
<p>This is tricky, because NVCC may invoke clang as part of its own compilation
process!  For example, NVCC uses the host compiler’s preprocessor when
compiling for device code, and that host compiler may in fact be clang.</p>
<p>When clang is actually compiling CUDA code – rather than being used as a
subtool of NVCC’s – it defines the <tt class="docutils literal"><span class="pre">__CUDA__</span></tt> macro.  <tt class="docutils literal"><span class="pre">__CUDA_ARCH__</span></tt> is
defined only in device mode (but will be defined if NVCC is using clang as a
preprocessor).  So you can use the following incantations to detect clang CUDA
compilation, in host and device modes:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#if defined(__clang__) &amp;&amp; defined(__CUDA__) &amp;&amp; !defined(__CUDA_ARCH__)</span>
  <span class="c1">// clang compiling CUDA code, host mode.</span>
<span class="cp">#endif</span>

<span class="cp">#if defined(__clang__) &amp;&amp; defined(__CUDA__) &amp;&amp; defined(__CUDA_ARCH__)</span>
  <span class="c1">// clang compiling CUDA code, device mode.</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>Both clang and nvcc define <tt class="docutils literal"><span class="pre">__CUDACC__</span></tt> during CUDA compilation.  You can
detect NVCC specifically by looking for <tt class="docutils literal"><span class="pre">__NVCC__</span></tt>.</p>
</div>
<div class="section" id="optimizations">
<h2><a class="toc-backref" href="#id5">Optimizations</a><a class="headerlink" href="#optimizations" title="Permalink to this headline"></a></h2>
<p>CPU and GPU have different design philosophies and architectures. For example, a
typical CPU has branch prediction, out-of-order execution, and is superscalar,
whereas a typical GPU has none of these. Due to such differences, an
optimization pipeline well-tuned for CPUs may be not suitable for GPUs.</p>
<p>LLVM performs several general and CUDA-specific optimizations for GPUs. The
list below shows some of the more important optimizations for GPUs. Most of
them have been upstreamed to <tt class="docutils literal"><span class="pre">lib/Transforms/Scalar</span></tt> and
<tt class="docutils literal"><span class="pre">lib/Target/NVPTX</span></tt>. A few of them have not been upstreamed due to lack of a
customizable target-independent optimization pipeline.</p>
<ul class="simple">
<li><strong>Straight-line scalar optimizations</strong>. These optimizations reduce redundancy
in straight-line code. Details can be found in the <a class="reference external" href="https://goo.gl/4Rb9As">design document for
straight-line scalar optimizations</a>.</li>
<li><strong>Inferring memory spaces</strong>. <a class="reference external" href="https://github.com/llvm-mirror/llvm/blob/master/lib/Target/NVPTX/NVPTXInferAddressSpaces.cpp">This optimization</a>
infers the memory space of an address so that the backend can emit faster
special loads and stores from it.</li>
<li><strong>Aggressive loop unrooling and function inlining</strong>. Loop unrolling and
function inlining need to be more aggressive for GPUs than for CPUs because
control flow transfer in GPU is more expensive. They also promote other
optimizations such as constant propagation and SROA which sometimes speed up
code by over 10x. An empirical inline threshold for GPUs is 1100. This
configuration has yet to be upstreamed with a target-specific optimization
pipeline. LLVM also provides <a class="reference external" href="http://clang.llvm.org/docs/AttributeReference.html#pragma-unroll-pragma-nounroll">loop unrolling pragmas</a>
and <tt class="docutils literal"><span class="pre">__attribute__((always_inline))</span></tt> for programmers to force unrolling and
inling.</li>
<li><strong>Aggressive speculative execution</strong>. <a class="reference external" href="http://llvm.org/docs/doxygen/html/SpeculativeExecution_8cpp_source.html">This transformation</a> is
mainly for promoting straight-line scalar optimizations which are most
effective on code along dominator paths.</li>
<li><strong>Memory-space alias analysis</strong>. <a class="reference external" href="http://reviews.llvm.org/D12414">This alias analysis</a> infers that two pointers in different
special memory spaces do not alias. It has yet to be integrated to the new
alias analysis infrastructure; the new infrastructure does not run
target-specific alias analysis.</li>
<li><strong>Bypassing 64-bit divides</strong>. <a class="reference external" href="http://llvm.org/docs/doxygen/html/BypassSlowDivision_8cpp_source.html">An existing optimization</a>
enabled in the NVPTX backend. 64-bit integer divides are much slower than
32-bit ones on NVIDIA GPUs due to lack of a divide unit. Many of the 64-bit
divides in our benchmarks have a divisor and dividend which fit in 32-bits at
runtime. This optimization provides a fast path for this common case.</li>
</ul>
</div>
<div class="section" id="publication">
<h2><a class="toc-backref" href="#id6">Publication</a><a class="headerlink" href="#publication" title="Permalink to this headline"></a></h2>
<div class="line-block">
<div class="line"><a class="reference external" href="http://dl.acm.org/citation.cfm?id=2854041">gpucc: An Open-Source GPGPU Compiler</a></div>
<div class="line">Jingyue Wu, Artem Belevich, Eli Bendersky, Mark Heffernan, Chris Leary, Jacques Pienaar, Bjarke Roune, Rob Springer, Xuetian Weng, Robert Hundt</div>
<div class="line"><em>Proceedings of the 2016 International Symposium on Code Generation and Optimization (CGO 2016)</em></div>
<div class="line"><a class="reference external" href="http://wujingyue.com/docs/gpucc-talk.pdf">Slides for the CGO talk</a></div>
</div>
</div>
<div class="section" id="tutorial">
<h2><a class="toc-backref" href="#id7">Tutorial</a><a class="headerlink" href="#tutorial" title="Permalink to this headline"></a></h2>
<p><a class="reference external" href="http://wujingyue.com/docs/gpucc-tutorial.pdf">CGO 2016 gpucc tutorial</a></p>
</div>
<div class="section" id="obtaining-help">
<h2><a class="toc-backref" href="#id8">Obtaining Help</a><a class="headerlink" href="#obtaining-help" title="Permalink to this headline"></a></h2>
<p>To obtain help on LLVM in general and its CUDA support, see <a class="reference external" href="http://llvm.org/docs/#mailing-lists">the LLVM
community</a>.</p>