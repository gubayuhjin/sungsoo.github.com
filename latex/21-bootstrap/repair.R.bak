############################################
#
#SYSTEM FAILS WHEN 4 MACHINES FAIL
#
#GENERATE ONE SYSTEM LIFE TIME
#
#
############################################
 set.seed(1235)
 x=NULL
 for (i in 1:4)x[i]=rexp(1,1)
 t.failure.arrival=min(x) #FIRST FAILURE TIME
 t.end.of.repair=Inf #NO end.of.repair EVENT PENDING
 r=0 #NO. OF FAILED MACHINES
 clock=min(t.failure.arrival, t.end.of.repair)  #TURN THE CLOCK
 #########################################################################
 while (r < 4) #SYSTEM IS RUNNING
 {
   if (clock == t.failure.arrival) ###ARRIVAL OF failure.arrival EVENT###
     {
       r=r+1
       if (r == 4) {break}
       ############### SCHEDULE NEXT FAILURE ARRIVAL
       x[which.min(x)]=clock+rexp(1,1)
       t.failure.arrival=min(x)
       #####################################################
       ############ HANDLE THE CURRENT ARRIVING FAILURE
       if (r == 1) #START REPAIRING AND SCHEDULE ITS end.of.repair
         t.end.of.repair=clock+rexp(1,2) #SCHEDULE ITS end.of.repair
       # else #THE CURRENT ARRIVING FAILURE WAITS IN Q
          #{########DO NOTHING  
          #}
       
     }
   else ###ARRIVAL OF end.of.repair EVENT###
     {
      ###UPDATE SYSTEM STATE
       r=r-1 
      ###SEE IF REPAIRMAN CAN TAKE A BREAK
       if (r > 0) t.end.of.repair=clock+rexp(1,2) ###SCHEDULE ITS end.of.repair
       else ###SET SERVER IDLE
         t.end.of.repair=Inf
     }   
   clock=min(t.failure.arrival, t.end.of.repair) #TURN THE CLOCK
 }
##########################################################################
 T=clock
 T
##################################################
##################################################
