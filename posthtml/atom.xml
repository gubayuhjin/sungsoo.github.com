<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>Sung-Soo Kim's Blog</title>
 <link href="/atom.xml" rel="self"/>
 <link href=""/>
 <updated>2013-12-14T17:42:56+09:00</updated>
 <id></id>
 <author>
   <name>Sung-Soo Kim</name>
   <email>sungsookim@kaist.ac.kr</email>
 </author>

 
 <entry>
   <title>N-Screen Application Development Manual</title>
   <link href="/2013/12/13/nscreen-manual.html"/>
   <updated>2013-12-13T00:00:00+09:00</updated>
   <id>/2013/12/13/nscreen-manual</id>
   <content type="html">&lt;p&gt;N-스크린 어플리케이션 라이브러리(NSAL)를 사용하여 N-스크린 앱을 개발하기 위한 절차를 기술한다.&lt;/p&gt;

&lt;h3&gt;개발 전에 준비해야 할 것들-   각 디바이스에는 협업 에이전트 서비스 (CA.apk)가 설치되어 있어야 한다.-    NScreen Application Library 파일(NSAL.jar)이 준비되어야 한다.-    Java JDK 버전 1.6을 사용할 것을 권장한다.-  안드로이드 버전 4.0 이상을 사용하여야 한다.-   각 NScreen App에 대한 InterAppRelation 정보를 담은 XML 파일을 각 디바이스의 지정된 폴더(/sdcard/CAInterAppRelation)에 저장해야 한다. -    InterAppRelation 정보를 담은 파일 이름은 InterAppRelation_[App Package ID].xml 이다.&lt;/h3&gt;

&lt;h3&gt;개발 절차- 프로젝트 생성후 libs 폴더에 NSAL.jar 파일을 복사해서 넣는다. (단 Build SDK는 4.0이상으로 맟춘다.)- 생성한 프로젝트의 Properties에 Java Build Path-&gt;Libraries-&gt;Add JARs를 눌러서 해당 프로젝트의 libs폴더안의 NSAL.jar파일을 선택한다.&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://sungsoo.github.com/images/nscreen-setting.png&quot; alt=&quot;http://sungsoo.github.com/images/nscreen-setting.png&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Order and Export탭에서 NSAL.Jar 파일을 체크한다.
&lt;img src=&quot;http://sungsoo.github.com/images/nscreen-buildpath.png&quot; alt=&quot;http://sungsoo.github.com/images/nscreen-buildpath.png&quot; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;AndroidManifest.xml에서 application 안에 그대로 service를 추가한다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;&amp;lt;service android:name=&quot;kr.re.etri.rdcm.nsal.NSALAidlService&quot;&amp;gt;   &amp;lt;intent-filter&amp;gt; &amp;lt;action android:name=&quot;개발하는앱의패키지명.AidlService&quot;&amp;gt;&amp;lt;/action&amp;gt; &amp;lt;/intent-filter&amp;gt;&amp;lt;/service&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Application Class를 상속 받을 클래스를 생성한다. 이때 반드시 NSALApplication 을 상속 받아야 한다.&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;package nscreen.searchinfo.test2;import kr.re.etri.rdcm.nsal.NSALApplication;public class NApps extends NSALApplication{    @Override   public void onCreate() {        // TODO Auto-generated method stub      super.onCreate();   }       @Override   public void onTerminate() {     // TODO Auto-generated method stub      super.onTerminate();    }}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;AndroidManifest.xml에서 application name을 생성한 클래스 이름으로 입력한다.&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;&amp;lt;application  android:name=&quot;.NApps&quot;        android:icon=&quot;@drawable/ic_launcher&quot;        android:label=&quot;@string/app_name&quot;        android:theme=&quot;@style/AppTheme&quot; &amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;구현할 Activity나 Service 클래스는 각각 NSALActivity와 NSALService를 상속 받아서 개발해야 한다.- MapActivity를 상속 받아야 할 경우에는 NSALMapActivity를 상속 받아서 개발해야 한다.

&lt;h3&gt;동일 협업세션에 참여하는 N-스크린 앱간 데이터 송수신* 같은 세션에 참여중인 다른 Device로 메시지를 보내고 싶으면 다음과 같이 &lt;code&gt;sendMessageToAppsInSession()&lt;/code&gt; method를 이용하여 메시지를 전송하면 된다.&lt;/h3&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;&lt;code&gt;NApps nApps=(NApps)getApplicationContext();nApps.sendMessageToAppsInSession(“message”);
```* 같은 세션에 참여 중인 다른 앱으로부터 메시지를 받고자 할 때 메시지를 수신할 Activity Class에 다음과 같이 리스
너를 등록한다. 아래 예에서는 NApps 클래스가 리스너인 경우이다. 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NApps nApps=(NApps)getApplicationContext();nApps.setOnReceiveListener(this);
&lt;code&gt;* NApps 클래스가 receiveHandler interface를 implement 하게 되면 ReceiveMessage 함수를 구현하여야 한다. 메세지 수신 핸들러가 생성되고 메시지메 수신 받을수 있게된다.* 같은 세션에 참여 중인 다른 앱으로부터 메시지가 올 경우 ReceiveMessage 함수가 호출된다. 참여중인 세션에 다른 App이 참여했을 때 다음 함수가 호출된다. 여기서, message는 메시지를 보낸 앱이 담은 스트링 값을 그대로 포함한다.&lt;/code&gt;
public void ReceiveMessage(String message) {        }```&lt;/p&gt;

&lt;h3&gt;자원인지 디바이스 협업 미들웨어를 이용한 주요 기능&lt;/h3&gt;

&lt;p&gt;자원인지 디바이스 협업 미들웨어(이하; 협업 에이전트)를 이용하여 N-스크린 어플리케이션이 수행할 수 있는 주요 기능들은 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;원격 실행 (Remote Execution)&lt;/li&gt;
&lt;li&gt;협업세션 참여 (Collaboration Session Join)&lt;/li&gt;
&lt;li&gt;협업세션 초대 (Collaboration Session Invitation)&lt;/li&gt;
&lt;li&gt;앱 푸쉬 이동 (Application Push Migration)&lt;/li&gt;
&lt;li&gt;앱 풀 이동 (Application Pull Migration)###References
[1] NScreen App 개발 매뉴얼, ETRI, 2012.&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>What is NoSQL?</title>
   <link href="/2013/12/12/nosql.html"/>
   <updated>2013-12-12T00:00:00+09:00</updated>
   <id>/2013/12/12/nosql</id>
   <content type="html">&lt;p&gt;One of the challenges with NoSQL is defining it. The term &lt;em&gt;NoSQL&lt;/em&gt; is problematic since it doesn’t really describe the core themes in the NoSQL movement. The term origi- nated from a group in the Bay Area who met regularly to talk about common con- cerns and issues surrounding scalable open source databases, and it stuck. Descriptive or not, it seems to be everywhere: in trade press, product descriptions, and confer- ences. We’ll use the term NoSQL in this article as a way of differentiating a system from a traditional relational database management system (RDBMS).
For our purpose, we define NoSQL in the following way:&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;NoSQL is a set of concepts that allows the rapid and efficient processing of data sets with a focus on performance, reliability, and agility.
Seems like a broad definition, right? It doesn’t exclude SQL or RDBMS systems, right? That’s not a mistake. What’s important is that we identify the core themes behind NoSQL, what it is, and most importantly what it isn’t.
So what is NoSQL?
* &lt;em&gt;It’s more than rows in tables&lt;/em&gt;—NoSQL systems store and retrieve data from many formats: key-value stores, graph databases, column-family (Bigtable) stores, doc- ument stores, and even rows in tables.
* &lt;em&gt;It’s free of joins&lt;/em&gt;—NoSQL systems allow you to extract your data using simple interfaces without joins.
* &lt;em&gt;It’s schema-free&lt;/em&gt;—NoSQL systems allow you to drag-and-drop your data into a folder and then query it without creating an entity-relational model.
* &lt;em&gt;It works on many processors&lt;/em&gt;—NoSQL systems allow you to store your database on multiple processors and maintain high-speed performance.
* &lt;em&gt;It uses shared-nothing commodity computers&lt;/em&gt;—Most (but not all) NoSQL systems leverage low-cost commodity processors that have separate RAM and disk.
* &lt;em&gt;It supports linear scalability&lt;/em&gt;—When you add more processors, you get a consistent increase in performance.
* &lt;em&gt;It’s innovative&lt;/em&gt;—NoSQL offers options to a single way of storing, retrieving, and manipulating data. NoSQL supporters (also known as &lt;em&gt;NoSQLers&lt;/em&gt;) have an inclu- sive attitude about NoSQL and recognize SQL solutions as viable options. To the NoSQL community, NoSQL means “Not only SQL.”
Equally important is what NoSQL is not:
* &lt;em&gt;It’s not about the SQL language&lt;/em&gt;—The definition of NoSQL isn’t an application that uses a language other than SQL. SQL as well as other query languages are used with NoSQL databases.
* &lt;em&gt;It’s not only open source&lt;/em&gt;—Although many NoSQL systems have an open source model, commercial products use NOSQL concepts as well as open source initia- tives. You can still have an innovative approach to problem solving with a com- mercial product.
* &lt;em&gt;It’s not only big data&lt;/em&gt;—Many, but not all, NoSQL applications are driven by the inability of a current application to efficiently scale when big data is an issue. Though volume and velocity are important, NoSQL also focuses on variability and agility.
* &lt;em&gt;It’s not about cloud computing&lt;/em&gt;—Many NoSQL systems reside in the cloud to take advantage of its ability to rapidly scale when the situation dictates. NoSQL sys- tems can run in the cloud as well as in your corporate data center.
* &lt;em&gt;It’s not about a clever use of RAM and SSD&lt;/em&gt;—Many NoSQL systems focus on the effi- cient use of RAM or solid state disks to increase performance. Though this is important, NoSQL systems can run on standard hardware.
* &lt;em&gt;It’s not an elite group of products&lt;/em&gt;—NoSQL isn’t an exclusive club with a few prod- ucts. There are no membership dues or tests required to join. To be considered a NoSQLer, you only need to convince others that you have innovative solutions to their business problems.
NoSQL applications use a variety of data store types (databases). From the simple key- value store that associates a unique key with a value, to graph stores used to associate relationships, to document stores used for variable data, each NoSQL type of data store has unique attributes and uses as identified in table 1.1.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://sungsoo.github.com/images/nosql-datastores.png&quot; alt=&quot;http://sungsoo.github.com/images/nosql-datastores.png&quot; /&gt;NoSQL systems have unique characteristics and capabilities that can be used alone or in conjunction with your existing systems. Many organizations considering NoSQL sys- tems do so to overcome common issues such as volume, velocity, variability, and agility, the business drivers behind the NoSQL movement.&lt;/p&gt;

&lt;h3&gt;NoSQL case studiesOur economy is changing. Companies that want to remain competitive need to find new ways to attract and retain their customers. To do this, the technology and people who create it must support these efforts quickly and in a cost-effective way. New thoughts about how to implement solutions are moving away from traditional meth- ods toward processes, procedures, and technologies that at times seem bleeding-edge.&lt;/h3&gt;

&lt;p&gt;The following case studies demonstrate how business problems have successfully been solved faster, cheaper, and more effectively by thinking outside the box. Table 1.2 summarizes five case studies where NoSQL solutions were used to solve particular busi- ness problems. It presents the problems, the business drivers, and the ultimate findings. As you view subsequent sections, you’ll begin to see a common theme emerge: some business problems require new thinking and technology to provide the best solution.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://sungsoo.github.com/images/nosql-casestudy01.png&quot; alt=&quot;http://sungsoo.github.com/images/nosql-casestudy01.png&quot; /&gt;
&lt;img src=&quot;http://sungsoo.github.com/images/nosql-casestudy02.png&quot; alt=&quot;http://sungsoo.github.com/images/nosql-casestudy02.png&quot; /&gt;###References
[1] DAN MCCREARY ANN KELLY, Making Sense of NoSQL: A GUIDE FOR MANAGERS AND THE REST OF US, pp.4-9, MANNING Publications, 2014.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Android WebView Application using Naver Open API</title>
   <link href="/2013/12/12/naver-openapi.html"/>
   <updated>2013-12-12T00:00:00+09:00</updated>
   <id>/2013/12/12/naver-openapi</id>
   <content type="html">&lt;h3&gt;네이버 계정으로 Open API 접속&lt;/h3&gt;

&lt;p&gt;네이버의 Open API 를 사용하여 뉴스, 이미지, 블로그 등등을 조회하기 위해서는 우선 Naver 에 회원가입이 되어있어야 하고, 네이버에 로그인을 해야 한다.
Open API 는 누구든지 key 를 발급 받으면 사용할 수 있으며, 일일동안에 접속하는 데이터량의 제한이 있다.
아래 이미지는 네이버 개발자 센터 홈페이지이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://sungsoo.github.com/images/naver-openapi.png&quot; alt=&quot;http://sungsoo.github.com/images/naver-openapi.png&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;Open API 확인&lt;/h3&gt;

&lt;p&gt;위 이미지에서 검색 API 메뉴를 클릭하면 검색 API 목록이 나온다. 검색 API 목록 중에서 이번 예제에서는 News 와 Image 목록을 안드로이드에서 조회하는 어플리케이션을 작성하려고 한다.
우선 검색을 하기 위해서는 네이버 개발사 사이트에서 키를 발급받아야 한다. 키를 발급받는 링크는 왼쪽 메뉴에 “키 등록/관리” 메뉴를 클릭한다.
검색 API 에 대한 key 와 지도 API key 두 가지 형태의 key 를 발급받을 수 있으며, 지도 API key 를 사용하고자 한다면, “키 추가” 버튼을 클릭하여 키를 추가한다.
아래 화면은 키 등록/관리를 통해 발급 받은 내역이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://sungsoo.github.com/images/openapi-key.png&quot; alt=&quot;http://sungsoo.github.com/images/openapi-key.png&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;Open API 테스트&lt;/h3&gt;

&lt;p&gt;다시 검색 API 메뉴를 선택하고, “뉴스” 항목을 선택하면, “뉴스 검색”에 대한 요청 URL 과 요청변수, 그리고 출력결과 필드의 정보를 확인할 수 있다. 샘플 URL 에서 나타낸 URL 과 key 를 사용하여 브라우저에서 뉴스를 검색해 본다.
다음은 뉴스 검색 안내 페이지이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://sungsoo.github.com/images/openapi-key.png&quot; alt=&quot;http://sungsoo.github.com/images/openapi-key.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그리고 샘플 URL 과 Key 를 사용하여 검색하면, 아래와 같이 RSS Feed 형태의 XML 데이터를 브라우저에서 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://sungsoo.github.com/images/search-news.png&quot; alt=&quot;http://sungsoo.github.com/images/search-news.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 XML 문서를 Parsing 하여 Andorid Application 에서 목록(ListView)으로 보여주려고 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://sungsoo.github.com/images/sample-search.png&quot; alt=&quot;http://sungsoo.github.com/images/sample-search.png&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;XML Parsing&lt;/h3&gt;

&lt;p&gt;Android 에서는 XML Parsing 하는데 있어, 크게 3 가지 형태를 사용하고 있다.
* SAX Parser 사용
* XMLPullParser 사용
* DOM Parser 사용
이번 예제에서는 이 세가지 방법을 모두 다뤄볼 것이며, 각각의 방식으로 XML Parsing 하는 소스코드도 함께 작성 할 것이다.&lt;/p&gt;

&lt;h3&gt;Android Project 생성&lt;/h3&gt;

&lt;p&gt;우선 Project 를 먼저 생성하여, Application 을 개발하기 위한 초기 작업을 수행한다.
Eclipse 를 실행하고, File -&gt; New -&gt; Android Project 메뉴를 선택한다.
* Project name : NaverApi
* Build Target : Android 2.3.3
* Package : nscreen.searchinfo&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://sungsoo.github.com/images/android-project.png&quot; alt=&quot;http://sungsoo.github.com/images/android-project.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Finish 버튼을 클릭하여 Project 를 생성한다.&lt;/p&gt;

&lt;h4&gt;News 클래스 생성&lt;/h4&gt;

&lt;p&gt;하나의 News 를 저장하는 News 클래스를 생성한다. Open API 를 사용하여, XML 데이터를 Parsing 하게 되면, 각각의 News 의 정보를 저장하기 위한 객체가 필요하다. 하나의 News 를 저장하기 위한 객체를 만들기 위해서 News 라는 이름의 클래스를 생성한다. 이 클래스에는 Naver 에서 News 의 정보를 제공해주는 각 항목을 저장하기 위한 멤버변수가 존재하게 된다.&lt;/p&gt;

&lt;p&gt;위의 XML 데이터에서 확인했듯이, 하나의 News 에 대한 여러가지 내용을 저장하기 위한 멤버변수를 정의한다.  Title, Link, OriginalLink, Date 등이 기본적으로 저장된다.
따라서 아래와 같이 News 클래스를 생성한다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package nscreen.searchinfo.news;

import java.net.MalformedURLException;
import java.net.URL;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
public class News implements Comparable&amp;lt;News&amp;gt; {
        static final String CHANNEL = &quot;channel&quot;;
    static final String PUB_DATE = &quot;pubDate&quot;;
    static final String DESCRIPTION = &quot;description&quot;;
    static final String LINK = &quot;link&quot;;
    static final String ORIGINAL_LINK = &quot;originallink&quot;;
    static final String TITLE = &quot;title&quot;;
    static final String ITEM = &quot;item&quot;;

        static SimpleDateFormat FORMATTER =
                        new SimpleDateFormat(&quot;EEE, dd MMM yyyy HH:mm:ss Z&quot;);
        static SimpleDateFormat FORMATTER_KR =
                        new SimpleDateFormat(&quot;yyyy년 MM월 dd일 HH시mm분ss초, E&quot;);
        private String title;
        private URL link;
        private URL originalLink;
        private String description;
        private Date date;
        public String getTitle() {
                return title;
        }
        public void setTitle(String title) {
                this.title = title;
        }
        public URL getLink() {
                return link;
        }
        public String getDescription() {
                return description;
        }
        public void setDescription(String description) {
                this.description = description;
        }
        public void setLink(String link) {
                try {
                        if (link != null  &amp;amp;&amp;amp; link.trim().length() &amp;gt; 0) {
                                this.link = new URL(&quot;link);
                        }
                } catch (MalformedURLException e) {
                        throw new RuntimeException(e);
                }
        }

        public URL getOriginalLink() {
                return originalLink;
        }
        public void setOriginalLink(String originalLink) {
                try {
                        if (originalLink != null &amp;amp;&amp;amp; originalLink.trim().length() &amp;gt; 0) {
                                this.originalLink = new URL(&quot;originalLink);
                        }
                } catch (MalformedURLException e) {
                        throw new RuntimeException(e);
                }
        }
        public String getDate() {
                return FORMATTER_KR.format(this.date);
        }
        public void setDate(String date) {
                while (!date.endsWith(&quot;00&quot;)){
                        date += &quot;0&quot;;
                }
                try {
                        this.date = FORMATTER.parse(date.trim());
                } catch (ParseException e) {
                        throw new RuntimeException(e);
                }
        }
        public int compareTo(News another) {
                if (another == null) return 1;
                return another.date.compareTo(date);
        }

        public News copy() {

                News news = new News();
                news.date = this.date;
                news.description = this.description;
                news.link = this.link;
                news.originalLink = this.originalLink;
                news.title = this.title;

                return news;
        }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;XML Parsing 클래스 생성&lt;/h4&gt;

&lt;p&gt;XML 데이터를 Pasring 하기 위한 interface와 공통 기능을 위한 클래스를 작성한다.
Android 에서 XML parsing 하는 방법은 크게 3가지 종류가 있다.&lt;/p&gt;

&lt;p&gt;네이버 검색 API를 이용한 어플리케이션을 구성하고 있는 주요 인터페이스 및 클래스는 다음과 같다.
* NewsFeedParser interface
* BaseNewsFeedParser abstract class
* RssHandler class
* SaxNewsFeedParser class
* AndroidSaxNewFeedParser class
* XMLPullNewsFeedParser class
* DomNewsFeedParser class&lt;/p&gt;

&lt;p&gt;Android에서 XML 종류별로 XML parsing하는 내용을 살펴볼 것이다. 우선 XML 데이터를 parsing 하기 위한 interface를 정의한다. 3 가지 parser에서 공통으로 사용되어질 메소드를 interface 에서 미리 정의한다.
이러한 설계 패턴을 &lt;em&gt;strategy pattern&lt;/em&gt;이라고 한다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package nscreen.searchinfo.news;
import java.util.List;
public interface NewsFeedParser {
        public List&amp;lt;News&amp;gt; parse();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;BaseNewFeedParser는 서버와 접속하여, XML 데이터를 얻은 다음, InputStream으로 데이터를 받는 역할을 수행한다. 3 가지 parser가 XML 데이터를 받는 작업을 수행한다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package nscreen.searchinfo.news;

import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.URL;
public abstract class BaseNewsFeedParser implements NewsFeedParser {

    final URL feedUrl;
    protected BaseNewsFeedParser(String feedUrl){
        try {
            this.feedUrl = new URL(&quot;feedUrl);
        } catch (MalformedURLException e) {
            throw new RuntimeException(e);
        }
    }
    protected InputStream getInputStream() {
        try {
            return feedUrl.openConnection().getInputStream();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SAXParsing을 하기 위한 DefaultHandler 클래스를 상속받는 RssHandler 클래스를 정의한다.
XML 데이터를 받고 나서, XML 데이터를 처음부터 끝까지 데이터를 읽으면서 parsing 하는 작업을 수행한다.
News 목록을 저장하기 위한 NewsList 와 하나의 News 를 저장하기 위한 News 클래스, 그리고 문자열 작업을 위한 StringBuilder 클래스를 사용하여, XML 데이터를 parsing 한다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package nscreen.searchinfo.news;

import java.util.ArrayList;
import java.util.List;
import org.xml.sax.Attributes;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;
public class RssHandler extends DefaultHandler {
        private List&amp;lt;News&amp;gt; newsList;
        private News currentNews;
        private StringBuilder builder;
        public List&amp;lt;News&amp;gt; getNewsList(){
                return this.newsList;
        }

        @Override
        public void characters(char[] ch, int start, int length)
                        throws SAXException {
                super.characters(ch, start, length);
                builder.append(ch, start, length);
        }
        @Override
        public void endElement(String uri, String localName, String name)
                        throws SAXException {
                super.endElement(uri, localName, name);

                if (this.currentNews != null){
                        if (localName.equalsIgnoreCase(News.TITLE)){
                                currentNews.setTitle(builder.toString());
                        } else if (localName.equalsIgnoreCase(News.LINK)){
                                currentNews.setLink(builder.toString());
                        } else if (localName.equalsIgnoreCase(News.ORIGINAL_LINK)){
                                currentNews.setOriginalLink(builder.toString());
                        } else if (localName.equalsIgnoreCase(News.DESCRIPTION)){
                                currentNews.setDescription(builder.toString());
                        } else if (localName.equalsIgnoreCase(News.PUB_DATE)){
                                currentNews.setDate(builder.toString());
                        } else if (localName.equalsIgnoreCase(News.ITEM)){
                                newsList.add(currentNews);
                        }
                }
                builder.setLength(0);    
        }
        @Override
        public void startDocument() throws SAXException {
                super.startDocument();
                newsList = new ArrayList&amp;lt;News&amp;gt;();
                builder = new StringBuilder();
        }
        @Override
        public void startElement(String uri, String localName, String name,
                        Attributes attributes) throws SAXException {
                super.startElement(uri, localName, name, attributes);
                if (localName.equalsIgnoreCase(News.ITEM)){
                        this.currentNews = new News();
                }
        }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SaxNewsFeedParser 클래스는 SaxParser를 사용하여 XML 데이터를 parsing하는 클래스이다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package nscreen.searchinfo.news;

import java.util.List;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
public class SaxNewsFeedParser extends BaseNewsFeedParser {
        protected SaxNewsFeedParser(String feedUrl){
        super(feedUrl);
    }

    public List&amp;lt;News&amp;gt; parse() {

        SAXParserFactory factory = SAXParserFactory.newInstance();

        RssHandler handler = new RssHandler();
        try {

                SAXParser parser = factory.newSAXParser();

            parser.parse(this.getInputStream(), handler);

        } catch (Exception e) {
            e.printStackTrace();
        }
        return handler.getNewsList();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;AndroidSaxNewFeedParser 클래스는 Android에서 제공하는 Sax XML parser, Event 중심의 XML parser다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package nscreen.searchinfo.news;

import java.util.ArrayList;
import java.util.List;
import android.sax.Element;
import android.sax.EndElementListener;
import android.sax.EndTextElementListener;
import android.sax.RootElement;
import android.util.Xml;
public class AndroidSaxNewsFeedParser extends BaseNewsFeedParser {
        static final String RSS = &quot;rss&quot;;

        protected AndroidSaxNewsFeedParser(String feedUrl) {
                super(feedUrl);
        }
        public List&amp;lt;News&amp;gt; parse() {

                final News currentNews = new News();

                RootElement root = new RootElement(RSS);

                final List&amp;lt;News&amp;gt; newsList = new ArrayList&amp;lt;News&amp;gt;();

                Element channel = root.getChild(News.CHANNEL);

                Element item = channel.getChild(News.ITEM);
                item.setEndElementListener(new EndElementListener(){
                        public void end() {
                                newsList.add(currentNews.copy());
                        }
                });
                item.getChild(News.TITLE).setEndTextElementListener(new EndTextElementListener(){
                        public void end(String body) {
                                currentNews.setTitle(body);
                        }
                });
                item.getChild(News.LINK).setEndTextElementListener(new EndTextElementListener(){
                        public void end(String body) {
                                currentNews.setLink(body);
                        }
                });
                item.getChild(News.DESCRIPTION).setEndTextElementListener(new EndTextElementListener(){
                        public void end(String body) {
                                currentNews.setDescription(body);
                        }
                });
                item.getChild(News.PUB_DATE).setEndTextElementListener(new EndTextElementListener(){
                        public void end(String body) {
                                currentNews.setDate(body);
                        }
                });

                try {
                        Xml.parse(this.getInputStream(), Xml.Encoding.UTF_8, root.getContentHandler());
                } catch (Exception e) {
                        e.printStackTrace();
                }

                return newsList;
        }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;XMLPullNewsFeedParser 클래스는 News 피드에 대한 pull parser다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package nscreen.searchinfo.news;

import java.util.ArrayList;
import java.util.List;
import org.xmlpull.v1.XmlPullParser;
import android.util.Xml;
public class XmlPullNewsFeedParser extends BaseNewsFeedParser {
        protected XmlPullNewsFeedParser(String feedUrl) {
                super(feedUrl);
        }
        public List&amp;lt;News&amp;gt; parse() {

                List&amp;lt;News&amp;gt; NewsList = null;

                XmlPullParser parser = Xml.newPullParser();

                try {

                        // auto-detect the encoding from the stream
                        parser.setInput(this.getInputStream(), null);

                        int eventType = parser.getEventType();

                        News currentNews = null;

                        boolean done = false;

                        while (eventType != XmlPullParser.END_DOCUMENT &amp;amp;&amp;amp; !done){

                                String name = null;

                                switch (eventType){

                                        case XmlPullParser.START_DOCUMENT:

                                                NewsList = new ArrayList&amp;lt;News&amp;gt;();
                                                break;

                                        case XmlPullParser.START_TAG:

                                                name = parser.getName();

                                                if (name.equalsIgnoreCase(News.ITEM)){
                                                        currentNews = new News();
                                                } else if (currentNews != null){

                                                        if (name.equalsIgnoreCase(News.LINK)){
                                                                currentNews.setLink(parser.nextText());
                                                        } else if (name.equalsIgnoreCase(News.ORIGINAL_LINK)){
                                                                currentNews.setOriginalLink(parser.nextText());
                                                        } else if (name.equalsIgnoreCase(News.DESCRIPTION)){
                                                                currentNews.setDescription(parser.nextText());
                                                        } else if (name.equalsIgnoreCase(News.PUB_DATE)){
                                                                currentNews.setDate(parser.nextText());
                                                        } else if (name.equalsIgnoreCase(News.TITLE)){
                                                                currentNews.setTitle(parser.nextText());
                                                        }        
                                                }
                                                break;

                                        case XmlPullParser.END_TAG:

                                                name = parser.getName();

                                                if (name.equalsIgnoreCase(News.ITEM) &amp;amp;&amp;amp; currentNews != null){
                                                        NewsList.add(currentNews);
                                                } else if (name.equalsIgnoreCase(News.CHANNEL)){
                                                        done = true;
                                                }
                                                break;
                                }

                                eventType = parser.next();
                        }

                } catch (Exception e) {
                        e.printStackTrace();
                }

                return NewsList;
        }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DomNewsFeedParser 클래스는 Dom으로 XML parsing을 수행하는 클래스다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.coremodeling.naver.news;
import java.util.ArrayList;
import java.util.List;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
public class DomNewsFeedParser extends BaseNewsFeedParser {
        public DomNewsFeedParser(String feedUrl) {
                super(feedUrl);
        }
        public List&amp;lt;News&amp;gt; parse() {

                DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();

                List&amp;lt;News&amp;gt; newsList = new ArrayList&amp;lt;News&amp;gt;();

                try {

                        DocumentBuilder builder = factory.newDocumentBuilder();
                        Document dom = builder.parse(this.getInputStream());

                        Element root = dom.getDocumentElement();
                        NodeList items = root.getElementsByTagName(News.ITEM);

                        for (int i=0;i&amp;lt;items.getLength();i++){

                                News news = new News();

                                Node item = items.item(i);

                                NodeList properties = item.getChildNodes();

                                for (int j=0;j&amp;lt;properties.getLength();j++){

                                        Node property = properties.item(j);

                                        String name = property.getNodeName();

                                        if (name.equalsIgnoreCase(News.TITLE)){
                                                // 특수 문자로 인해서 텍스트가 여러개로 나뉘는 경우가 발생하여, 하나로 합친다.
                                                StringBuilder text = new StringBuilder();
                                                NodeList chars = property.getChildNodes();
                                                for (int k=0; k &amp;lt;chars.getLength(); k++){
                                                        text.append(chars.item(k).getNodeValue());
                                                }
                                                news.setTitle(text.toString());
                                        } else if (name.equalsIgnoreCase(News.LINK)){
                                                news.setLink(property.getFirstChild().getNodeValue());
                                        } else if (name.equalsIgnoreCase(News.ORIGINAL_LINK)){
                                                Node firstChild = property.getFirstChild();
                                                String originalLink = &quot;&quot;;
                                                if (firstChild != null) {
                                                        originalLink = firstChild.getNodeValue();
                                                }
                                                news.setOriginalLink(originalLink);
                                        } else if (name.equalsIgnoreCase(News.DESCRIPTION)){
                                                news.setDescription(property.getFirstChild().getNodeValue());
                                        } else if (name.equalsIgnoreCase(News.PUB_DATE)){
                                                news.setDate(property.getFirstChild().getNodeValue());
                                        }
                                }

                                newsList.add(news);
                        }

                } catch (Exception e) {
                        e.printStackTrace();
                }

                return newsList;
        }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;화면 디자인&lt;/h3&gt;

&lt;p&gt;News 를 검색하고, 검색한 결과를 목록으로 화면에 나와야 하기 때문에, 검색하기 위한 입력창과 버튼, 그리고 목록을 처리할 수 있는 화면을 디자인한다.
아래와 같이 /res/layout/newslist.xml 파일을 생성하고, XML 파일을 디자인한다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
        android:orientation=&quot;vertical&quot; android:layout_width=&quot;fill_parent&quot;
        android:layout_height=&quot;fill_parent&quot;&amp;gt;
        &amp;lt;RelativeLayout android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/relativeLayout1&quot;&amp;gt;
                &amp;lt;Button android:layout_height=&quot;wrap_content&quot; android:onClick=&quot;onClickSearch&quot;
                        android:layout_width=&quot;wrap_content&quot; android:text=&quot;검색&quot; android:id=&quot;@+id/btnSearch&quot;
                        android:layout_alignParentTop=&quot;true&quot; android:layout_alignParentRight=&quot;true&quot;&amp;gt;&amp;lt;/Button&amp;gt;
                &amp;lt;EditText android:layout_height=&quot;wrap_content&quot;
                        android:layout_width=&quot;fill_parent&quot; android:id=&quot;@+id/editSearch&quot;
                        android:layout_toLeftOf=&quot;@id/btnSearch&quot;
                        android:layout_alignParentTop=&quot;true&quot; android:layout_alignParentLeft=&quot;true&quot;&amp;gt;
                        &amp;lt;requestFocus&amp;gt;&amp;lt;/requestFocus&amp;gt;
                &amp;lt;/EditText&amp;gt;
        &amp;lt;/RelativeLayout&amp;gt;
        &amp;lt;ListView android:layout_height=&quot;wrap_content&quot; android:id=&quot;@android:id/list&quot;
                android:layout_width=&quot;fill_parent&quot;&amp;gt;&amp;lt;/ListView&amp;gt;
&amp;lt;/LinearLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그리고 목록의 각 행을 디자인하기 위한 XML 파일을 /res/layout/news_row.xml 파일을 생성하고 아래와 같이 디자인한다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
        android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;&amp;gt;
        &amp;lt;TextView android:layout_width=&quot;wrap_content&quot; android:text=&quot;TextView&quot;
                android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/textViewTitle&quot;
                android:textAppearance=&quot;?android:attr/textAppearanceMedium&quot;&amp;gt;&amp;lt;/TextView&amp;gt;
        &amp;lt;TextView android:text=&quot;TextView&quot; android:id=&quot;@+id/textViewTime&quot;
                android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot;&amp;gt;&amp;lt;/TextView&amp;gt;
&amp;lt;/LinearLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Activity 구현&lt;/h3&gt;

&lt;p&gt;Activity 를 아래와 같이 구현한다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package nscreen.searchinfo;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import android.app.ListActivity;
import android.os.Bundle;
import android.view.View;
import android.widget.EditText;
import android.widget.SimpleAdapter;
import com.coremodeling.naver.news.News;
import com.coremodeling.naver.news.NewsFeedParser;
import com.coremodeling.naver.news.SaxNewsFeedParser;
public class NaverApiActivity extends ListActivity {
    /** Called when the activity is first created. */
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.newslist);
    }

    public void onClickSearch(View view) {
            loadData();
    }

    private void loadData() {

            String newsUrl = &quot;http://openapi.naver.com/search?key=네이버검색키입력&quot; +
                            &quot;&amp;amp;target=news&amp;amp;start=1&amp;amp;display=20&amp;amp;query=&quot;;

            EditText editText = (EditText)findViewById(R.id.editSearch);

            String query = editText.getText().toString();

            NewsFeedParser newsFeedParser = new SaxNewsFeedParser(newsUrl + query);

            List&amp;lt;News&amp;gt; newsList = newsFeedParser.parse();

            List&amp;lt;Map&amp;lt;String, String&amp;gt;&amp;gt; xmlList = new ArrayList&amp;lt;Map&amp;lt;String,String&amp;gt;&amp;gt;();

            for (News news : newsList) {

                    Map&amp;lt;String, String&amp;gt; newsMap = new HashMap&amp;lt;String, String&amp;gt;();
                    newsMap.put(&quot;title&quot;, news.getTitle());
                    newsMap.put(&quot;date&quot;, news.getDate());

                    xmlList.add(newsMap);
                }

            String[] from = {&quot;title&quot;, &quot;date&quot;};

            int[] to = {R.id.textViewTitle, R.id.textViewTime};

            SimpleAdapter simpleAdapter = new SimpleAdapter(this, xmlList, R.layout.news_row, from, to);

            setListAdapter(simpleAdapter);

    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그리고 인터넷에 접근할 수 있는 권한을 사용하기 위해서, AndroidManifest.xml 파일에 INTERNET 을 use permission 으로 추가해야 한다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
      package=&quot;com.coremodeling.naver&quot;
      android:versionCode=&quot;1&quot;
      android:versionName=&quot;1.0&quot;&amp;gt;
    &amp;lt;uses-sdk android:minSdkVersion=&quot;10&quot; /&amp;gt;
    &amp;lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;&amp;gt;&amp;lt;/uses-permission&amp;gt;
    &amp;lt;application android:icon=&quot;@drawable/icon&quot; android:label=&quot;@string/app_name&quot;&amp;gt;
        &amp;lt;activity android:name=&quot;.NaverApiActivity&quot;
                  android:label=&quot;@string/app_name&quot;&amp;gt;
            &amp;lt;intent-filter&amp;gt;
                &amp;lt;action android:name=&quot;android.intent.action.MAIN&quot; /&amp;gt;
                &amp;lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&amp;gt;
            &amp;lt;/intent-filter&amp;gt;
        &amp;lt;/activity&amp;gt;
    &amp;lt;/application&amp;gt;
&amp;lt;/manifest&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;실행 결과&lt;/h3&gt;

&lt;p&gt;아래와 같이 실행한 결과를 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://sungsoo.github.com/images/result-app.png&quot; alt=&quot;http://sungsoo.github.com/images/result-app.png&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;References&lt;/h3&gt;

&lt;p&gt;[1] 안드로이드에서 네이버 News API 사용, &lt;a href=&quot;http://www.coremodeling.com/android/tutorial/NaverNewsFeed/NaverNewsFeed.html&quot;&gt;NaverNewFeed&lt;/a&gt;, September, 2011.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>YARN (MapReduce 2)</title>
   <link href="/2013/12/12/mr-job-rn.pnsg.html"/>
   <updated>2013-12-12T00:00:00+09:00</updated>
   <id>/2013/12/12/mr-job-rn.pnsg</id>
   <content type="html">&lt;p&gt;For very large clusters in the region of 4000 nodes and higher, the MapReduce system described in the previous section begins to hit scalability bottlenecks, so in 2010 a group at Yahoo! began to design the next generation of MapReduce. The result was &lt;em&gt;YARN&lt;/em&gt;, short for &lt;strong&gt;Yet Another Resource Negotiator&lt;/strong&gt; (or if you prefer recursive ancronyms, YARN Application Resource Negotiator).&lt;/p&gt;

&lt;p&gt;YARN meets the scalability shortcomings of “classic” MapReduce by splitting the re- sponsibilities of the jobtracker into separate entities. The jobtracker takes care of both job scheduling (matching tasks with tasktrackers) and task progress monitoring (keep- ing track of tasks and restarting failed or slow tasks, and doing task bookkeeping such as maintaining counter totals).&lt;/p&gt;

&lt;p&gt;YARN separates these two roles into two independent daemons: a &lt;em&gt;resource manager&lt;/em&gt; to manage the use of resources across the cluster, and an &lt;em&gt;application master&lt;/em&gt; to manage the lifecycle of applications running on the cluster. The idea is that an application master negotiates with the resource manager for cluster resources—described in terms of a number of &lt;em&gt;containers&lt;/em&gt; each with a certain memory limit—then runs application- specific processes in those containers. The containers are overseen by &lt;em&gt;node managers&lt;/em&gt; running on cluster nodes, which ensure that the application does not use more resour- ces than it has been allocated.
In contrast to the &lt;em&gt;jobtracker&lt;/em&gt;, each instance of an application—here a MapReduce job —has a dedicated application master, which runs for the duration of the application. This model is actually closer to the original Google MapReduce paper, which describes how a master process is started to coordinate map and reduce tasks running on a set of workers.
As described, YARN is more general than MapReduce, and in fact MapReduce is just one type of YARN application. There are a few other YARN applications—such as a distributed shell that can run a script on a set of nodes in the cluster—and others are actively being worked on (some are listed at &lt;a href=&quot;http://wiki.apache.org/hadoop/PoweredByYarn&quot;&gt;PoweredByYarn&lt;/a&gt;). The beauty of YARN’s design is that different YARN applications can co-exist on the same cluster—so a MapReduce application can run at the same time as an MPI application, for example—which brings great benefits for managability and cluster utilization.
Furthermore, it is even possible for users to run different versions of MapReduce on the same YARN cluster, which makes the process of upgrading MapReduce more managable. (Note that some parts of MapReduce, like the job history server and the shuffle handler, as well as YARN itself, still need to be upgraded across the cluster.)
MapReduce on YARN involves more entities than classic MapReduce. They are:
The client, which submits the MapReduce job.
• The YARN resource manager, which coordinates the allocation of compute re- sources on the cluster.&lt;br/&gt;
• The YARN node managers, which launch and monitor the compute containers on machines in the cluster.
• The MapReduce application master, which coordinates the tasks running the MapReduce job. The application master and the MapReduce tasks run in con- tainers that are scheduled by the resource manager, and managed by the node managers.
• The distributed filesystem (normally HDFS), which is used for sharing job files between the other entities.
The process of running a job is shown in the below figure, and described in the following sections.
&lt;img src=&quot;http://sungsoo.github.com/images/mr-yarn.png&quot; alt=&quot;http://sungsoo.github.com/images/mr-yarn.png&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;Job SubmissionJobs are submitted in MapReduce 2 using the same user API as MapReduce 1 (step 1). MapReduce 2 has an implementation of ClientProtocol that is activated when &lt;code&gt;mapreduce.framework.name&lt;/code&gt; is set to yarn. The submission process is very similar to the classic implementation. The new job ID is retrieved from the resource manager (rather than the jobtracker), although in the nomenclature of YARN it is an application ID (step 2). The job client checks the output specification of the job; computes input splits (although there is an option to generate them on the cluster, &lt;code&gt;yarn.app.mapreduce.am.com pute-splits-in-cluster&lt;/code&gt;, which can be beneficial for jobs with many splits); and copies job resources (including the job JAR, configuration, and split information) to HDFS (step 3). Finally, the job is submitted by calling &lt;code&gt;submitApplication()&lt;/code&gt; on the resource manager (step 4).### Job InitializationWhen the resource manager receives a call to its &lt;code&gt;submitApplication()&lt;/code&gt;, it hands off the request to the scheduler. The scheduler allocates a container, and the resource manager then launches the application master’s process there, under the node manager’s man- agement (steps 5a and 5b).&lt;/h3&gt;

&lt;p&gt;The application master for MapReduce jobs is a Java application whose main class is &lt;code&gt;MRAppMaster&lt;/code&gt;. It initializes the job by creating a number of bookkeeping objects to keep track of the job’s progress, as it will receive progress and completion reports from the tasks (step 6). Next, it retrieves the input splits computed in the client from the shared filesystem (step 7). It then creates a map task object for each split, and a number of reduce task objects determined by the &lt;code&gt;mapreduce.job.reduces&lt;/code&gt; property.
The next thing the application master does is decide how to run the tasks that make up the MapReduce job. If the job is small, the application master may choose to run them in the same JVM as itself, since it judges the overhead of allocating new containers and running tasks in them as outweighing the gain to be had in running them in parallel, compared to running them sequentially on one node. (This is different to MapReduce 1, where small jobs are never run on a single tasktracker.) Such a job is said to be &lt;em&gt;uberized&lt;/em&gt;, or run as an &lt;em&gt;uber task&lt;/em&gt;.
What qualifies as a small job? By default one that has less than 10 mappers, only one reducer, and the input size is less than the size of one HDFS block. (These values may be changed for a job by setting &lt;code&gt;mapreduce.job.ubertask.maxmaps&lt;/code&gt;, &lt;code&gt;mapreduce.job.uber task.maxreduces&lt;/code&gt;, and &lt;code&gt;mapreduce.job.ubertask.maxbytes&lt;/code&gt;.) It’s also possible to disable uber tasks entirely (by setting &lt;code&gt;mapreduce.job.ubertask.enable&lt;/code&gt; to &lt;em&gt;false&lt;/em&gt;).
Before any tasks can be run the job setup method is called (for the job’s &lt;code&gt;OutputCommit ter&lt;/code&gt;), to create the job’s output directory. In contrast to MapReduce 1, where it is called in a special task that is run by the tasktracker, in the YARN implementation the method is called directly by the application master.&lt;/p&gt;

&lt;h3&gt;Task AssignmentIf the job does not qualify for running as an uber task, then the application master requests containers for all the map and reduce tasks in the job from the resource man- ager (step 8). Each request, which are piggybacked on heartbeat calls, includes infor- mation about each map task’s data locality, in particular the hosts and corresponding racks that the input split resides on. The scheduler uses this information to make scheduling decisions (just like a jobtracker’s scheduler does): it attempts to place tasks on data-local nodes in the ideal case, but if this is not possible the scheduler prefers rack-local placement to non-local placement.&lt;/h3&gt;

&lt;p&gt;Requests also specify memory requirements for tasks. By default both map and reduce tasks are allocated 1024 MB of memory, but this is configurable by setting mapre duce.map.memory.mb and &lt;code&gt;mapreduce.reduce.memory.mb&lt;/code&gt;.
The way memory is allocated is different to MapReduce 1, where tasktrackers have a fixed number of “slots”, set at cluster configuration time, and each task runs in a single slot. Slots have a maximum memory allowance, which again is fixed for a cluster, and which leads both to problems of under utilization when tasks use less memory (since other waiting tasks are not able to take advantage of the unused memory) and problems of job failure when a task can’t complete since it can’t get enough memory to run correctly.
In YARN, resources are more fine-grained, so both these problems can be avoided. In particular, applications may request a memory capability that is anywhere between the minimum allocation and a maximum allocation, and which must be a multiple of the minimum allocation. Default memory allocations are scheduler-specific, and for the capacity scheduler the default minimum is 1024 MB (set by &lt;code&gt;yarn.scheduler.capacity.minimum-allocation-mb&lt;/code&gt;), and the default maximum is 10240 MB (set by &lt;code&gt;yarn.scheduler.capacity.maximum-allocation-mb&lt;/code&gt;). Thus, tasks can request any memory allocation between 1 and 10 GB (inclusive), in multiples of 1 GB (the scheduler will round to the nearest multiple if needed), by setting &lt;code&gt;mapreduce.map.memory.mb and map reduce.reduce.memory.mb&lt;/code&gt; appropriately.&lt;/p&gt;

&lt;h3&gt;Task ExecutionOnce a task has been assigned a container by the resource manager’s scheduler, the application master starts the container by contacting the node manager (steps 9a and 9b). The task is executed by a Java application whose main class is YarnChild. Before it can run the task it localizes the resources that the task needs, including the job con- figuration and JAR file, and any files from the distributed cache (step 10). Finally, it runs the map or reduce task (step 11).&lt;/h3&gt;

&lt;p&gt;The YarnChild runs in a dedicated JVM, for the same reason that tasktrackers spawn new JVMs for tasks in MapReduce 1: to isolate user code from long-running system daemons. Unlike MapReduce 1, however, YARN does not support JVM reuse so each task runs in a new JVM.
Streaming and Pipes programs work in the same way as MapReduce 1. The &lt;strong&gt;Yarn Child&lt;/strong&gt; launches the Streaming or Pipes process and communicates with it using standard input/output or a socket (respectively), as shown in Figure 6-2 (except the child and subprocesses run on node managers, not tasktrackers).&lt;img src=&quot;http://sungsoo.github.com/images/stream-pipe.png&quot; alt=&quot;http://sungsoo.github.com/images/stream-pipe.png&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;Progress and Status UpdatesWhen running under YARN, the task reports its progress and status (including coun- ters) back to its application master every three seconds (over the umbilical interface), which has an aggregate view of the job. The process is illustrated in the below figure. Contrast this to MapReduce 1, where progress updates flow from the child through the task- tracker to the jobtracker for aggregation.&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://sungsoo.github.com/images/updates-mr-yarn.png&quot; alt=&quot;http://sungsoo.github.com/images/updates-mr-yarn.png&quot; /&gt;
The client polls the application master every second (set via &lt;code&gt;mapreduce.client.pro gressmonitor.pollinterval&lt;/code&gt;) to receive progress updates, which are usually displayed to the user.&lt;/p&gt;

&lt;h3&gt;Job CompletionAs well as polling the application master for progress, every five seconds the client checks whether the job has completed when using the &lt;code&gt;waitForCompletion()&lt;/code&gt; method on &lt;strong&gt;Job&lt;/strong&gt;. The polling interval can be set via the &lt;code&gt;mapreduce.client.completion.polli nterval&lt;/code&gt; configuration property.&lt;/h3&gt;

&lt;p&gt;Notification of job completion via an HTTP callback is also supported like in MapRe- duce 1. In MapReduce 2 the application master initiates the callback.
On job completion the application master and the task containers clean up their work- ing state, and the &lt;strong&gt;OutputCommitter&lt;/strong&gt;’s job cleanup method is called. Job information is archived by the job history server to enable later interrogation by users if desired.###References
[1] Tome White, Hadoop: The Definitive Guide, pp.194-200, Third Edition, 2012.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Stream Data Schema Design</title>
   <link href="/2013/12/11/stream-data-schema.html"/>
   <updated>2013-12-11T00:00:00+09:00</updated>
   <id>/2013/12/11/stream-data-schema</id>
   <content type="html">&lt;h3&gt;Stream Data Schema for Real-time Data Stream Manager&lt;/h3&gt;

&lt;h3&gt;Streaming Information&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt; &lt;strong&gt;Type:&lt;/strong&gt; Environmental data: temperatures, pressures, salinity, acidity, fluid velocities etc,&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt; &lt;strong&gt;Nature:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Relational Stream: yes&lt;/li&gt;
&lt;li&gt;Text stream: no&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt; &lt;strong&gt;Origin:&lt;/strong&gt; Data is produced by sensors in oil wells and on oil and gas platforms equipments. Each oil platform has an average of 400,000.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt; &lt;strong&gt;Frequency of update:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;from sub-second to minutes&lt;/li&gt;
&lt;li&gt;In triples/minute: [10000-10] t/min&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt; &lt;strong&gt;Quality:&lt;/strong&gt; It varies, due to instrument/sensor issues&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt; &lt;strong&gt;Management /access&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Technology in use: Dedicated (relational and proprietary) stores&lt;/li&gt;
&lt;li&gt;Problems: The ability of users to access data from different sources is limited by an insufficient description of the context&lt;/li&gt;
&lt;li&gt;Means of improvement: Add context (metadata) to the data so it become meaningful and use reasoning techniques to process that metadata&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;[optional] Static Information required to interpret the streaming information&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt; &lt;strong&gt;Type:&lt;/strong&gt; Topology of the sensor network, position of each sensor, the descriptions of the oil platform&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt; &lt;strong&gt;Origin:&lt;/strong&gt; Oil and gas production operations&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt; &lt;strong&gt;Dimension:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;100s of MB as PostGIS dump&lt;/li&gt;
&lt;li&gt;In triples: 10&lt;sup&gt;8&lt;/sup&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt; &lt;strong&gt;Quality:&lt;/strong&gt; Good&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt; &lt;strong&gt;Management /access&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Technology in use: RDBMS, proprietary technologies&lt;/li&gt;
&lt;li&gt;Available Ontologies and Vocabularies: Reference Semantic Model (RSM), based on ISO 15926&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;References&lt;/h3&gt;

&lt;p&gt;[1] W3C, Use cases - RDF Stream Processing Community Group, &lt;a href=&quot;http://www.w3.org/community/rsp/wiki/Use_cases&quot;&gt;link&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Introduction to Stream Computing</title>
   <link href="/2013/12/11/stream-computing-examples.html"/>
   <updated>2013-12-11T00:00:00+09:00</updated>
   <id>/2013/12/11/stream-computing-examples</id>
   <content type="html">&lt;h3&gt;Stream Computing - Examples&lt;/h3&gt;

&lt;h4&gt;General Examples&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Monitoring streams of low-level sensor inputs and emitting high-level interpretations of the raw data&lt;/li&gt;
&lt;li&gt;Responding to streams emanating from sensor inputs by emitting actuator commands&lt;/li&gt;
&lt;li&gt;Monitoring streams of data from Intrusion Detection sensor inputs and emitting alerts&lt;/li&gt;
&lt;li&gt;Monitoring streams of video data and interpreting scenes, scene changes, etc.&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;InfoSphere Streams Examples&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Traffic control system which takes in GPS information from public vehicles and caculates deviations from normal to recommend alternative routes&lt;/li&gt;
&lt;li&gt;Real-time correlation of information from multiple neonatal ICU monitors to detect potential life threatening conditions up to 24 hours earlier than an experienced ICU nurse&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;The Need for Stream Computing&lt;/h3&gt;

&lt;p&gt;A need for real-time analytics on &lt;strong&gt;BIG data&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Volume&lt;/strong&gt;&lt;br/&gt;
Millions/Billions of events per second&lt;br/&gt;
Terabytes/Petabytes per day&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Variety&lt;/strong&gt;&lt;br/&gt;
All kinds of data&lt;br/&gt;
All kinds of analytics&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Velocity&lt;/strong&gt;&lt;br/&gt;
Insights in microseconds&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Agility&lt;/strong&gt;&lt;br/&gt;
Dynamically responsive&lt;br/&gt;
Rapid application development&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;img src=&quot;http://sungsoo.github.com/images/big-data.png&quot; alt=&quot;http://sungsoo.github.com/images/big-data.png&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;Traditional Computing&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Historical fact finding&lt;/li&gt;
&lt;li&gt;Find and analyse information stored on disk&lt;/li&gt;
&lt;li&gt;Batch paradigm, pull model&lt;/li&gt;
&lt;li&gt;Query-driven: submit queries to static data&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;Stream Computing&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Current fact finding&lt;/li&gt;
&lt;li&gt;Analyze data in motion - before it is stored&lt;/li&gt;
&lt;li&gt;Low latency paradigm, push model&lt;/li&gt;
&lt;li&gt;Data-driven: bring data to the analytics&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;What is Stream Processing?&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Relational databases and warehouses find information stored on disk&lt;/li&gt;
&lt;li&gt;Streams analyses data before you store it&lt;/li&gt;
&lt;li&gt;Databases find the needle in the haystack&lt;/li&gt;
&lt;li&gt;Streams finds the needle as it&#39;s blowing by&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;References&lt;/h3&gt;

&lt;p&gt;[1] Brian Williams, IBM InfoSphere Streams Developer Education Section 1, October 2013.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Streams Application Design</title>
   <link href="/2013/12/10/streams-application-design.html"/>
   <updated>2013-12-10T00:00:00+09:00</updated>
   <id>/2013/12/10/streams-application-design</id>
   <content type="html">&lt;p&gt;Let us assume that you have been tasked with producing a business requirement using the &lt;strong&gt;IBM InfoSphere Streams&lt;/strong&gt; platform. The first thing you need to do is develop a high level system design that identifies the main components of the system.As shown in Figure 3-1, there are two main components to this design:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A &lt;em&gt;logical&lt;/em&gt; design identifying the application components to be produced.&lt;/li&gt;
&lt;li&gt;A &lt;em&gt;physical&lt;/em&gt; component design identifying the runtime components and hardware platform required to support your application and deliver the level of performance that is required.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;At run time, the &lt;em&gt;Streams Scheduler&lt;/em&gt; determines how to efficiently segment the application across the hardware hosts. The application should be segmented to produce suitably sized deployable &lt;em&gt;Processing Elements&lt;/em&gt; for the Streams Scheduler to deploy.
&lt;img src=&quot;http://sungsoo.github.io/images/application-design.png&quot; alt=&quot;http://sungsoo.github.io/images/application-design.png&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;References&lt;/h3&gt;

&lt;p&gt;[1] Chuck Ballard et. al, IBM InfoSphere Streams: Harnessing Data in Motion, IBM Redbooks, September 2010.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Filter pattern</title>
   <link href="/2013/12/10/filter-pattern.html"/>
   <updated>2013-12-10T00:00:00+09:00</updated>
   <id>/2013/12/10/filter-pattern</id>
   <content type="html">&lt;p&gt;When you are processing &lt;em&gt;large volumes&lt;/em&gt; of data, a large proportion of the data may be considered to be irrelevant to your analysis. For example, you may only be interested in &lt;em&gt;infrequent&lt;/em&gt;, &lt;em&gt;unusual&lt;/em&gt; occurrences within the data streams.
In this case, a &lt;strong&gt;Streams Application&lt;/strong&gt; can be used to filter the data, reducing it to the items of significance. The application might analyze the data stream, identify the elements of interest, and create a new stream of data from the significant items. With this new stream, a reduced number of these valuable parts will be processed by the remainder of the Streams Application.Figure 3-3 shows the principle of the &lt;strong&gt;Filter pattern&lt;/strong&gt;. The application reduces the volume of data so that the output is more manageable.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://sungsoo.github.io/images/filter-pattern.png&quot; alt=&quot;http://sungsoo.github.io/images/filter-pattern.png&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;ExampleIn &lt;em&gt;financial services&lt;/em&gt;, you might be interested in price changes for stocks in your stock portfolio. You can consume a feed of data from the stock market and use a filter to reduce this feed down to only the stocks of interest to you.&lt;/h3&gt;

&lt;p&gt;In a &lt;em&gt;health care&lt;/em&gt; situation, a large volume of readings will be generated from medical sensors. These will usually stay within an expected range, but when they fall outside this range, an alert needs to be raised. A filter can be used to detect the dangerous sensor readings.&lt;/p&gt;

&lt;h3&gt;StereotypeA simple implementation of the &lt;em&gt;Filter design pattern&lt;/em&gt; illustrating value identification and extraction is shown in Figure 3-4. In this illustration, a &lt;strong&gt;Source Operator&lt;/strong&gt; reads in the data stream and a &lt;strong&gt;Functor Operator&lt;/strong&gt; is used to determine the Tuples of interest and only passes these on to the &lt;strong&gt;Sink Operator&lt;/strong&gt;, which sends theses to the relevant recipients.&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://sungsoo.github.io/images/stype-filter-pattern.png&quot; alt=&quot;http://sungsoo.github.io/images/stype-filter-pattern.png&quot; /&gt;&lt;/p&gt;

&lt;h4&gt;Stereotype walkthroughHere are brief descriptions of the steps involved in the stereotype:&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;A &lt;em&gt;Source Operator&lt;/em&gt; reads in the data stream from the &lt;code&gt;input.dat&lt;/code&gt; file, creating the unfilteredInput stream.2. A &lt;em&gt;Functor Operator&lt;/em&gt; processes the &lt;strong&gt;unfilteredInput&lt;/strong&gt; stream and determines the Tuples of interest, in this case those strings that are greater than the string &lt;br/&gt;
&lt;strong&gt;Interesting Data.&lt;/strong&gt; The output stream from the Functor is the FilteredOutput stream and only contains the Tuples of interest.3. A &lt;em&gt;Sink Operator&lt;/em&gt; takes the &lt;strong&gt;FilteredOutput&lt;/strong&gt; stream and outputs the data to a file named &lt;code&gt;output.dat;&lt;/code&gt; this data will be used by relevant recipients.###VariationsThere might be variations in the process, but they may be handled by the following types of options:* The filtering logic offered by the standard Functor Operator can be extended by adding user defined logic, allowing the maintenance of state variables and the use of control logic (such as loops and if-else conditions).&lt;/li&gt;
&lt;li&gt;For more complex analysis, the Functor Operator may be expanded into multiple Operators, processing the stream in multiple serial or parallel steps.Some sample code that illustrates how that implementation might be supported is shown in Example 3-1.```
Example 3-1&lt;/li&gt;
&lt;/ol&gt;


&lt;hr /&gt;

&lt;p&gt;[Application]   Filter[Program]
stream UnfilteredInput (schemafor(Schema))   := Source ()         [&quot;file:///input.dat&quot;, csvformat, nodelays]         {}stream FilteredOutput (schemafor(Schema))   := Functor (UnfilteredInput)   [field = &quot;Interesting Data&quot;]   {}Nil := Sink (FilteredOutput) [&quot;file:///output.dat&quot;, csvformat, nodelays]
    {}```&lt;/p&gt;

&lt;h3&gt;SuggestionsWhen processing high volume streams, you should consider filtering the streams to reduce their volumes as soon as possible after they are ingested. This can reduce the total processing workload of the Application, allowing a higher volume of throughput, with lower latency and potentially using less hardware.&lt;/h3&gt;

&lt;p&gt;Figure 3-5 shows two contrasting filtering approaches. The top diagram shows a &lt;strong&gt;Streams Application&lt;/strong&gt; that filters the Source streams early on in its processing and the bottom diagram shows a &lt;strong&gt;Streams Application&lt;/strong&gt; that filters the Source streams later on in its processing.
&lt;img src=&quot;http://sungsoo.github.io/images/filtering-type.png&quot; alt=&quot;http://sungsoo.github.io/images/filtering-type.png&quot; /&gt;
In these figures, the area depicted as the Streams Application is proportional to the amount of processing that the application needs to perform. In the &lt;em&gt;early filtering&lt;/em&gt; case, most of the Streams Application only has a small number of data Tuples to process, so the shaded area is relatively small. In the &lt;em&gt;late filtering&lt;/em&gt; case, most of the Streams Application has a large number of data Tuples to process, so that area is far larger, indicating a greater processing workload for the application.###References
[1] Chuck Ballard et. al, IBM InfoSphere Streams: Harnessing Data in Motion, IBM Redbooks, pp.88, September 2010.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Analytics vs. Predictive Analytics</title>
   <link href="/2013/12/09/what-is-analytics.html"/>
   <updated>2013-12-09T00:00:00+09:00</updated>
   <id>/2013/12/09/what-is-analytics</id>
   <content type="html">&lt;h3&gt;What is Analytics?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Wikipedia&lt;/strong&gt;&lt;br/&gt;
“… the application of computer technology, operations research and statistics to solve problems in business and industry. Analytics is carried out within an information system.”
&lt;strong&gt;Competing on Analytics&lt;/strong&gt;(Tom Davenport)&lt;br/&gt;
&quot;… the application of computer technology, operations research and statistics to solve problems in business and industry. Analytics is carried out within an information system.&quot;&lt;/p&gt;

&lt;p&gt;Using analytics is like driving your car but watching traffic through the rear-view mirror, not seeing what’s ahead and thereby in danger of crashing.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Analytics&lt;/em&gt; is the understanding of existing (retrospective) data with the goal of understanding trends via comparison.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Developing analytics is the first step towards deriving predictive analytics&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;What is &lt;em&gt;Preditive&lt;/em&gt; Analytics?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Wikipedia&lt;/strong&gt;&lt;br/&gt;
&quot;predictive models exploit patterns found in historical and transactional data to identify risks and opportunities. Models capture relationships among many factors to allow assessment of risk or potential associated with a particular set of conditions, guiding decision making for candidate transactions&quot;
&lt;strong&gt;Competing on Analytics&lt;/strong&gt;(Tom Davenport)&lt;br/&gt;
“Any solution that supports the identification of meaningful patterns and correlations among variables in complex, structured and unstructured, historical, and potential future data sets for the purposes of predicting future events and assessing the attractiveness of various courses of action.”&lt;/p&gt;

&lt;p&gt;Using predictive analytics is like driving your car and watching traffic through the front windshield, anticipating traffic, making course corrections to avoid traffic jams and getting there faster and safer.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Predictive Analytics&lt;/em&gt; are more sophisticated analytics that “forward thinking” in nature.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;They used for gaining insights from mathematical and/or financial modeling by enhancing understanding, interpretation and judgment for the purpose of good decision making.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;References&lt;/h3&gt;

&lt;p&gt;[1] Jay Roy, Introduction to Predictive Analytics - Part I, Predictive Dashboards, May 2011.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Streams design patterns</title>
   <link href="/2013/12/09/streams-design-patterns.html"/>
   <updated>2013-12-09T00:00:00+09:00</updated>
   <id>/2013/12/09/streams-design-patterns</id>
   <content type="html">&lt;p&gt;&lt;em&gt;Design patterns&lt;/em&gt; are a formalization of common structures and interactions that arise repeatedly from the process of designing a range of applications. The approach of identifying design patterns and documenting them in a standard format is a way to simplify the design process. An understanding of these common design patterns should enable you to use them as &lt;em&gt;building blocks&lt;/em&gt; for your particular design. The design of an application can then be constructed as a combination of design patterns rather than a combination of individual Operators. This is easier to understand and means that you are able to benefit from the distilled design wisdom of previous successful applications.As implementations of &lt;strong&gt;Streams&lt;/strong&gt; grow, you should expect the number and types of design patterns to also grow. The following design patterns have been identified at this time:- &lt;em&gt;Filter pattern&lt;/em&gt; for data reduction- &lt;em&gt;Outlier pattern&lt;/em&gt; for data classification and outlier detection- &lt;em&gt;Parallel pattern&lt;/em&gt; for high volume data transformation- &lt;em&gt;Pipeline pattern&lt;/em&gt; for high volume data transformation- &lt;em&gt;Alerting pattern&lt;/em&gt; for real-time decision making and alerting- &lt;em&gt;Enrichment pattern&lt;/em&gt; for supplementing data- &lt;em&gt;Unstructured Data pattern&lt;/em&gt; for supporting unstructured data analysis- &lt;em&gt;Consolidation pattern&lt;/em&gt; for combining multiple sources- &lt;em&gt;Merge Pattern&lt;/em&gt; for combining similar sources- &lt;em&gt;Integration Pattern&lt;/em&gt; for leveraging existing analytics###References
[1] Chuck Ballard et. al, IBM InfoSphere Streams: Harnessing Data in Motion, IBM Redbooks, pp.88, September 2010.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Publications</title>
   <link href="/2013/12/09/international-journals.html"/>
   <updated>2013-12-09T00:00:00+09:00</updated>
   <id>/2013/12/09/international-journals</id>
   <content type="html">&lt;h3&gt;International Journals&lt;/h3&gt;

&lt;p&gt;[1] Y.M. Kang, H.G. Cho, &lt;strong&gt;S.S Kim&lt;/strong&gt;, Plausible and Realtime Rendering of Scratched Metal by Deforming MDF of Normal Mapped Anisotropic Surface, Journal of WSCG, Vol 19, Number 1-3, pp.101-109, 2011.
[2] &lt;strong&gt;S. S Kim&lt;/strong&gt;, S. W. Nam, I. H. Lee, Fast Ray-Triangle Intersection Computation Using Reconfigurable Hardware, Lecture Notes in Computer Science (MIRAGE 2007).
[3] &lt;strong&gt;S. S. Kim&lt;/strong&gt;, S. W. Nam, D. H. Kim and I. H. Lee, Hardware-Accelerated Ray-Triangle Intersection Testing for High-Performance Collision Detection, Journal of WSCG, Vol 15, Number 3, ISSN 1213-6972, ISBN 978-80-86943-00-8.
[4] M. G. Cho, Y. J. Yu, &lt;strong&gt;S. S. Kim&lt;/strong&gt;, Traffic Prediction System using Real-time Traffic Information, Lecture Notes in Computer Science (LNCS: ICCSA 2006)
[5] Y. B. Kang, &lt;strong&gt;S. S. Kim&lt;/strong&gt;, A New Route Determination Approach using Future Traffic Prediction, Journal of WSEAS Transactions on Systems,Vol. 4(6), pp. 804-811, 2005. ISSN 1109-2777.
[6] &lt;strong&gt;S. S. Kim&lt;/strong&gt;, S. K. Choe, Stylized Silhouette Rendering using Progressive Meshes, Journal of WSCG, Vol 10, Number 3, pp. 51-58, Feb. 2002.&lt;/p&gt;

&lt;h3&gt;Domestic Journals&lt;/h3&gt;

&lt;p&gt;[1] J. H. Lee, &lt;strong&gt;S. S. Kim&lt;/strong&gt;, H. J. Park, Comparing BRDF Models: Representation of Measured BRDF, Transactions on SCCE, Vol. 14, No. 5, 2009.&lt;/p&gt;

&lt;p&gt;[2] &lt;strong&gt;S. S. Kim&lt;/strong&gt;, K. H. Kim, K. O. Kim, Web-Based Media GIS Architecture using the Virtual World Mapping Technique, Korean Journal of Remote Sensing, Vol. 19, No. 1, pp. 71-80, 2003.&lt;/p&gt;

&lt;p&gt;[3] &lt;strong&gt;S. S. Kim&lt;/strong&gt;, S. H. Lee, K. O. Kim, J. H. Lee, Video GIS using Virtual World Mapping Technique, Journal of the Korean Geo-spatial Information Society, Sep. 2002. (in Korean)&lt;/p&gt;

&lt;h3&gt;International Conferences&lt;/h3&gt;

&lt;p&gt;[1] Y. B. Kang, S. S. Kim, A Fastest Route Planning for LBS Based On Traffic Prediction, 9th WSEAS International Conference on Systems, Athens, Greece, July 2005. [Best Paper Award]&lt;/p&gt;

&lt;p&gt;[2] S. S. Kim, K. H. Kim, S. H. Lee, J. H. Lee, Video Navigation System using Geographic Hypermedia, ISPRS Hannover Workshop 2005 (May 17-20), Hannover, Germany, May 2005.&lt;/p&gt;

&lt;p&gt;[3] S. S. Kim, J. H. Park, Geographic Hypermedia using Search Space Transformation, IEEE International Conference on Pattern Recognition (ICPR) 2004, Aug. 2004.&lt;/p&gt;

&lt;p&gt;[4] S. S. Kim, J. H. Park, Linking Geographic Hypermedia using the Remotely Sensed Data, IEEE International Conference on Multimedia and Expo (ICME) 2004, June. 2004.&lt;/p&gt;

&lt;p&gt;[5] S. S. Kim, J. H. Park, Efficient Routing Service for the Open LBS Services, GeoInformatics 2004, June. 2004.&lt;/p&gt;

&lt;p&gt;[6] S. S. Kim, K. S. Kim, J. C. Kim, J. H. Lee, Efficient Route Determination Technique in LBS System, ISRS(International Symposium on Remote Sensing) 2003, Nov. 2003.&lt;/p&gt;

&lt;p&gt;[7] S. S. Kim, S. H. Lee, K. H. Kim, J. H. Lee, A Unified Visualization Framework for Spatial and
Temporal Analysis in 4D GIS, IEEE International Geoscience and Remote Sensing Symposium 2003, Toulouse, France, July, 2003.&lt;/p&gt;

&lt;p&gt;[8] K. H. Kim, S. S. Kim, S. H. Lee, J. H. Park, J. H. Lee, The Interactive Geographic Video, IEEE International Geoscience and Remote Sensing Symposium 2003, Toulouse, France, July, 2003.&lt;/p&gt;

&lt;p&gt;[9] J. C. Kim, S. S. Kim, T. W. Heo, J. H. Park, OpenLS Directory Service Architectures and Implementation based on Web-Service, International Symposium on Remote Sensing (ISRS) 2003, Nov. 2003.&lt;/p&gt;

&lt;p&gt;[10] K. H. Kim, S. S. Kim, Sung-Ho Lee, K. O. Kim, J. H. Lee, GeoVideo: The Video Geographic Information System as a First Step Toward Media GIS, ASPRS&#39;2003 Conference, 2003.&lt;/p&gt;

&lt;p&gt;[11] S. S. Kim, S. H. Lee, K. H. Kim, J. H. Lee, Media GIS Web Service Architecture using Three-Dimensional GIS Database, ISRS 2002, Oct. 2002.&lt;/p&gt;

&lt;p&gt;[12] K. H. Kim, S. S. Kim, Sung-Ho Lee, K. O. Kim, J. H. Lee, GeoVideo: A First Step to MediaGIS, ISRS 2002, Oct. 2002.&lt;/p&gt;

&lt;p&gt;[13] S. H. Lee, K. H. Kim, S. S. Kim, K. O. Kim, Representing Topological Relationships for 3-Dimensional Spatial Features, ISRS 2002, Oct. 2002.&lt;/p&gt;

&lt;p&gt;[14] S. S. Kim, S. H. Lee, J. H. Park, Y. K. Yang, Rule-based Modeling for 3D GIS, In Proceedings of WSCG&#39;2002, pp. 21-24, Feb. 2002.&lt;/p&gt;

&lt;p&gt;[15] S. S. Kim, J. H. Park, Space-Efficient Terrain Rendering using Constrained Delaunay Triangulation, IEEE International Geoscience and Remote Sensing Symposium (IGARSS) 2002, Toronto, Canada, June 2002.&lt;/p&gt;

&lt;p&gt;[16] S. S. Kim, S. H. Lee, S. K. Choe, J. H. Lee, Component-Based 3D GIS Software Design for the Urban Planning, MIS&#39;2002 incorporating GIS and Remote Sensing, pp. 205-214, April 2002.&lt;/p&gt;

&lt;p&gt;[17] S. S. Kim, S. K. Choe, J. H. Lee, Y. K. Yang, Rule-Based Modeler Component Design for 3D GIS Software, In Proceedings of ISRS 2001, pp. 89-94, Oct. 2001.&lt;/p&gt;

&lt;p&gt;[18] S. S. Kim, S. K. Choe, J. H. Lee, Y. K. Yang, Level-of-Detail-based Rendering and Compression for 3D GIS, IGARSS’2001, July 2001.&lt;/p&gt;

&lt;p&gt;[19] S. S. Kim, K. H. Kim, J. H. Lee, Comparison of Slot Reuse Algorithms for CRMA High Speed Networks, In Proceedings of World Multiconference on Systemics, Cybernetics and Informatics (ISAS/SCI 2001), Volume V, pp. 229-233, 2001.&lt;/p&gt;

&lt;p&gt;[20] S. S. Kim, J. H. Cho, S. K. Choe, Y. K. Yang, Feature-Based Graph Matching Algorithm for Image Mosaicing, In Proceedings of World Multiconference on Systemics, Cybernetics and Informatics (ISAS/SCI 2001), Volume VI, pp. 315-319, 2001.&lt;/p&gt;

&lt;p&gt;[21] S. K. Choe, K. H. Kim, S. H. Lee, S. S. Kim, Y. K. Yang, Parametric Design and Visualization in 3-dimensional GIS Software Development, In Proceedings of ISRS 2001, pp. 128-131, Oct. 2001.&lt;/p&gt;

&lt;p&gt;[22] S. H. Lee, Kyung-Ho Kim, S. K. Choe, S. S. Kim, Y. K. Yang, Extension of OpenGIS OLE/COM SFS for 3-Dimensional GIS, In Proceedings of ISRS2001, pp. 248-251, Oct. 2001.&lt;/p&gt;

&lt;p&gt;[23] S. S. Kim, Y. S. Kim, M. G. Cho, H. G. Cho, A Geometric Compression Algorithm for Massive Terrain Data Using Delaunay Triangulation, In Proceedings of WSCG&#39;99, pp. 124-131, Feb. 1999.&lt;/p&gt;

&lt;p&gt;[24] J. K. Park, Y. M. Kang, S. S. Kim, H. G. Cho, Expressive Character Animation with Energy Constraints, In Proceedings of COMPUGRAPHICS&#39;97, Dec. 1997.&lt;/p&gt;

&lt;h3&gt;Domestic Conferences (in Korean)&lt;/h3&gt;

&lt;p&gt;[1] S. S. Kim, J. C. Kim, K. S. Kim, J. H. Park, J. H. Lee, Route Determination Service for Open LBS, Korean Information Processing Society Fall Conference, Nov. 2003.&lt;/p&gt;

&lt;p&gt;[2] J. C. Kim, T.W. Heo, S. S. Kim, K. S. Kim, J. H. Park, J. H. Lee, Directory Web Service based on EJB, Korean Information Processing Society Fall Conference, Nov. 2003.&lt;/p&gt;

&lt;p&gt;[3] T. W. Heo, J. C. Kim, S. S. Kim, K. S. Kim, J. H. Park, J. H. Lee, The Implementation of OpenLS Presentation Web Service, Korean Information Processing Society Fall Conference, Nov. 2003.&lt;/p&gt;

&lt;p&gt;[4] S. S. Kim, K.H. Kim, S. H. Lee, J. H. Park, Efficient Implementation of 4D GIS for Spatio-Temporal Analysis, Korean Information Science Society Spring Conference, April, 2003.&lt;/p&gt;

&lt;p&gt;[5] S. H. Lee, S. S. Kim, K.H. Kim, J. H. Park, Data Provider Service in 4D GIS, Korean Information Science Society Spring Conference, April, 2003.&lt;/p&gt;

&lt;p&gt;[6] S. S. Kim, S. H. Lee, K.H. Kim, K. O. Kim, Media GIS using 3D Graphic Mapping Technique, Korean Information Science Society Fall Conference, Oct. 2002.&lt;/p&gt;

&lt;p&gt;[7] S. S. Kim, K.H. Kim, J. H. Lee, Video Geographic Information Service using 4S-Van Camera Data, Korean Information Processing Society Fall Conference, Nov. 2002.&lt;/p&gt;

&lt;p&gt;[8] S. H. Lee, K. H. Kim, S. S. Kim, K. O. Kim, Topological Relationships of Three-Dimensional Spatial Features, Korean Information Processing Society Fall Conference, Nov. 2002.&lt;/p&gt;

&lt;p&gt;[9] S. S. Kim, S. H. Lee, J. C. Jeon, J. H. Park, Progressive Silhouette Rendering with Mesh Simplification for Silhouette Preservation, HCI Korea 2002 Conference, Feb. 2002.&lt;/p&gt;

&lt;p&gt;[10] K. H. Kim, S. S. Kim, S. H. Lee, J. H. Lee, GeoVideo: Video Geographic Information Systems, Korean Information Science Society Spring Conference, April. 2002.&lt;/p&gt;

&lt;p&gt;[11] S. S. Kim, K. H. Kim, J. H. Lee, 3D Terrain Rendering using Contour Line Data, Korean Information Science Society Spring Conference, pp. 625-627, April 2001.&lt;/p&gt;

&lt;p&gt;[12] S. S. Kim, Progressive Silhouette Rendering using Level-of-Detail Meshes, Korean Information Science Society Fall Conference, pp. 505-507, Oct. 2001.&lt;/p&gt;

&lt;p&gt;[13] S. S. Kim, S. H. Lee, Y. K. Yang, Slot Reuse Algorithm for CRMA High Speed Networks, Korean Information Science Society Fall Conference, pp. 160-162, Oct. 2001. (in English)&lt;/p&gt;

&lt;p&gt;[14] S. S. Kim, S. H. Lee, J. H. Lee, Y. K. Yang, Terrain Reconstruction from Contour Lines, Korean Information Processing Society Fall Conference, pp. 641-644, Oct. 2001.&lt;/p&gt;

&lt;p&gt;[15] S. S. Kim, S. K. Choe, J. H. Lee, Y. K. Yang, The Design of Scene Modeler Component for 3D GIS Software, Korean Information Processing Society Fall Conference, pp. 81-84, Oct. 2001.&lt;/p&gt;

&lt;p&gt;[16] S. S. Kim, K. S. Kim, S. H. Lee, S. K. Choe, K.H. Kim, J. H. Lee, Y. K. Yang, The Three-Dimensional Extension for Mapbase Components using the Rule-Based Modeling, Korean Multimedia Society Fall Conference, pp. 171-176, Nov. 2001.&lt;/p&gt;

&lt;p&gt;[17] S. H. Lee, S. S. Kim, Y. K. Yang, OpenGIS OLE/COM SFS Extension for 3D GIS , Korean Information Science Society Fall Conference, Oct. 2001.&lt;/p&gt;

&lt;p&gt;[18] J. C. Jeon, S. S. Kim, Y. J. Yim, Y. K. Yang, Real-time motion computation using CCD camera images, Inductive Weapon Conference, Agency for Defense Development, 2001.&lt;/p&gt;

&lt;p&gt;[19] J. H. Cho, S. S. Kim, T. C. Yang, Effective Silhouette Edge Rendering using Parameterized Brush Functions, Korean Information Science Society Fall Conference, Oct. 2000.&lt;/p&gt;

&lt;p&gt;[20] J. H. Cho, S. S. Kim, Y. T. Kim, Mesh Simplification for Volume and Boundary Preservation, Korean Information Science Society Fall Conference, pp. 583-585, 1999.&lt;/p&gt;

&lt;p&gt;[21] S. S. Kim, Y. J. Yu, J. M. Park, H. G. Cho, Terrain Simplification using New Cost Function, Korean Information Science Society Fall Conference, pp. 644-646, 1998.&lt;/p&gt;

&lt;p&gt;[22] J. K. Park, Y. M. Kang, S. S. Kim, H. G. Cho, Character Animation Technique using Energy Constraints, Korean Information Science Society Fall Conference, pp.587-590, 1997.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>The evolution of analytics</title>
   <link href="/2013/12/09/analytics-history.html"/>
   <updated>2013-12-09T00:00:00+09:00</updated>
   <id>/2013/12/09/analytics-history</id>
   <content type="html">&lt;p&gt;Just as the business landscape and information environments are evolving, the approaches to effective analysis are at the dawn of a major evolution. While we might be thinking that the wealth of information swarming around us sometimes seems more like a pestilence than prosperity, the fact is that we now have the capability to glean value from the chaos. Advanced software analytic tools and sophisticated mathematical models can help us identify patterns, correlations of events, and outliers. With these new tools, we can begin to anticipate, forecast, predict, and make changes in our systems with more clarity and confidence than ever before. We stand on the brink of the next generation of intelligence: analysis of insightful and relevant information in real time. This is the real value of a Smarter Planet.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://sungsoo.github.io/images/bi-gen.png&quot; alt=&quot;http://sungsoo.github.io/images/bi-gen.png&quot; /&gt;&lt;em&gt;Hierarchical databases&lt;/em&gt; were invented in the 1960s and still serve as the foundation for &lt;strong&gt;Online Transaction Processing (OLTP)&lt;/strong&gt; systems for all forms of business and government driving trillions of transactions. Consider the example of a bank. In many banks, the information is entered into an OLTP system by employees or by a web application that captures and stores that data in hierarchical databases. This information then appears in daily reports and graphical dashboards to demonstrate the current state of the business and to enable and support appropriate actions. Analytical processing here is limited to capturing and understanding what has happened.
&lt;em&gt;Relational databases&lt;/em&gt; brought with them the concept of &lt;em&gt;data warehousing&lt;/em&gt;, which extended the use of databases from OLTP to &lt;strong&gt;Online Analytic Processing (OLAP)&lt;/strong&gt;. Using an apparel manufacturer as an example, the order information that is captured by the OLTP system is stored over time and made available to the various business analysts in the organization. With OLAP, the analysts could now use the stored data to determine trends in fulfillment rates, patterns of inventory control issues, causes of order delays, and so on. By combining and enriching the data with the results of their analyses, they could do even more complex analyses to forecast future manufacturing levels or make recommendations to accelerate shipping methods. Additionally, they could mine the data and look for patterns to help them be more proactive in predicting potential future problems in areas such as order fulfillment. They could then analyze the recommendations to decide if they should take action. Thus, the core value of OLAP is understanding why things happen, which allows you to make more informed recommendations.
A key component of both OLTP and OLAP is that the data is stored. Some new applications require faster analytics than is possible, and you have to wait until the data is retrieved from storage. To meet the needs of these new dynamic applications, you must take advantage of the increase in the availability of data prior to storage, that is, streaming data. This need is driving the next evolution in analytic processing, Real-time Analytic Processing (RTAP). RTAP focuses on taking the proven analytics established in OLAP to the next level. Data in motion and unstructured data might be able to provide actual data where OLAP had to settle for assumptions and hunches. The speed of RTAP allows for taking immediate action instead of simply making recommendations.So, what type of analysis makes sense to do in real time? Key types of RTAP include, but are not limited to:* &lt;strong&gt;Alerting&lt;/strong&gt;&lt;br/&gt;
The RTAP application notifies the user(s) that the analysis has identified that a situation (based on a set of rules or process models) has occurred and provides options and recommendations for appropriate actions.&lt;br/&gt;
Alerts are useful in situations where the application should not be automatically modifying the process or automatically taking action. They are also effective in situations where the action to be taken is outside the scope of influence of the RTAP application.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Examples:&lt;/strong&gt;&lt;br/&gt;
A market surveillance application that is monitoring a local exchange for suspect activity would notify someone when such a situation occurs.&lt;br/&gt;
A patient monitoring application would alert a nurse to take a particular action, such as administering additional medicine.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Feedback&lt;/strong&gt;&lt;br/&gt;
The RTAP application identifies that a situation (based on a set of rules or process models) has occurred and makes the appropriate modifications to the processes to prevent further problems or to correct the problems that have already occurred.&lt;br/&gt;
Feedback analysis is useful in, for example, manufacturing scenarios where the application has determined that defective items have been produced and takes action to modify components to prevent further defects.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt; A manufacturer of plastic containers might run an application that uses the data from sensors on the production line to check the quality of the items through the manufacturing cycle. If defective items are sensed, the application generates instructions to the blending devices to adjust the ingredients to prevent further defects from occurring.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Detecting failures&lt;/strong&gt;&lt;br/&gt;
The RTAP application is designed to notice when a data source does notrespond or generate data in a prescribed period of time.&lt;br/&gt;
Failure detection is useful in determining system failure in remote locations or problems in communication networks.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Examples:&lt;/strong&gt;&lt;br/&gt;
An administrator for a critical communications network deploys an application to continuously test that the network is delivering an adequate response time. When the application determines that the speed drops below a certain level or is not responding at all, it alerts the administrator.&lt;br/&gt;
An in-home health monitoring application determines that the motion sensors for a particular subscriber have not been activated today and sends an alert to a caregiver to check on the patient to determine why they are not moving around.When you look at the big picture, you can see that if you consider the improvements that have been made in chip capacity, network protocols, and input / output caching along with the advances in instrumentation and interconnectivity and the potential of stream computing, we stand poised and ready to be able to present appropriate information to the decision makers in time for proactive action to be taken. The days of solely basing our decisions on static data is yielding to being able to also use streaming data or data in motion.&lt;/p&gt;

&lt;h3&gt;References[1] IBM InfoSphere Streams: Harnessing Data in Motion, IBM Redbooks, Sep. 2010.&lt;/h3&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>Thermodynamics Basic Concepts</title>
   <link href="/2013/11/09/Themodynamics.html"/>
   <updated>2013-11-09T00:00:00+09:00</updated>
   <id>/2013/11/09/Themodynamics</id>
   <content type="html">&lt;h3&gt;열역학은 열역학 0법칙부터 3법칙까지 4개의 법칙에 관한 것이다.&lt;/h3&gt;

&lt;h4&gt;열역학 제0법칙(zeroth law of thermodynamics)은&lt;/h4&gt;

&lt;p&gt;열적 평형을 설명하는 법칙입니다. 즉, 계(系)의 물체 A와 C가 열적 평형상태에 있고 B와 C가 열적 평형상태에 있으면, A와 B도 열평형상태에 있다는 법칙입니다. 이것은 온도의 존재를 주장하는 것과 같으며, 열역학의 기본적 출발점이 됩니다. 즉 열역학 제0법칙은 모든 물체는 온도라는 특성을 가지고 있으며 두 물체가 열적 평형상태에 있다면 둘의 온도는 같다는 사실을 설명하고 있습니다. 실험실에서 열역학 제0법칙은 항상 사용됩니다. 두 물체의 온도가 같은지 알고 싶다면 각각의 물체의 온도를 측정하면 됩니다. 즉, 두 물체를 접촉시키고 둘 사이에 열평형을 이루어졌는지 알 필요가 없습니다. 이 법칙은 열역학 제1법칙, 제2법칙이 발견된 후 발견되었습니다. 하지만 논리적으로 앞서기 때문에 열역학 제0법칙이라 했습니다. 온도라는 개념이 두 법칙의 기본이므로 온도가 유효한 개념임을 정립하는 법칙을 제0법칙으로 명명한 것입니다.&lt;/p&gt;

&lt;h4&gt;열역학 제1법칙(first law of thermodynamics)은&lt;/h4&gt;

&lt;p&gt;보다 일반화된 에너지 보존법칙의 표현입니다. 계의 내부에너지 변화는 계가 흡수한 열과 계가 한일의 차이이므로 계의 내부에너지는 열의 형태로 더해지면 증가하고 계가 일을 하면 감소합니다. 계가 열을 흡수하면 내부에너지는 증가하고 방출하면 내부에너지는 감소합니다. 그리고 계가 일을 하면 내부에너지는 감소하고 계가 외부로부터 일을 받으면 내부에너지는 증가합니다. 열역학 제1법칙의 특수한 경우로 4가지가 있습니다. 첫째, 단열과정입니다. 열역학 제1법칙 E = Q - W 에서 Q = 0인 경우입니다. 즉 외부로부터 열의 출입이 없는 경우입니다. 그러면 E = -W가 됩니다. 이는 외부와 열에너지 전달이 일어나지 않는 과정입니다. 계(System)가 일을 하면 내부에너지는 그만큼 감소하고, 반대로 계가 외부로부터 일을 받으면 내부에너지는 그만큼 증가합니다. 단열벽은 계에 출입하는 열을 완벽하게 막습니다. 계와 주위 사이에서 에너지가 전달될 수 있는 방법은 오직 납알을 올리거나 내리는것 뿐입니다. 피스톤 위에 납알을 올리면 기체가 압축되어 계가 한 일은 음의 값이고 내부에너지는 증가합니다. 반면 납알을 내리면 기체가 팽창되어 계가 한 일은 양의 값이고 내부에너지는 감소합니다. 둘째, 등적과정입니다. 열역학 제1법칙 E = Q - W 에서 W = 0인 경우입니다. 즉 부피가 일정합니다. 계가 열을 흡수하면 계의 내부에너지는 증가하고 반대로 열을 잃으면 내부에너지가 감소합니다. 셋째, 순환과정입니다. 열역학 제1법칙 E = Q - W 에서 E = 0인 경우입니다. 그러면 Q = W가 됩니다. 즉 내부에너지는 변하지 않습니다. 순환과정 동안 알짜일은 열의 형태로 전달된 알짜에너지와 정확히 같고 계의 내부에너지는 변하지 않습니다. 넷째, 자유팽창입니다. 열역학 제1법칙 E = Q - W 에서 Q = W = 0인 경우입니다. 그러면 E = 0이 됩니다. 자유팽창은 계와 주위 사이에 열전달이 없고, 계가 일도 하지 않는 단열 과정입니다. 자유팽창에서 잠금마개가 열리면 기체는 자유팽창을 하여 양쪽 공간을 모두 채웁니다. 이때 두 공간은 단열되어 있으므로 외부와 열전달은 없습니다. 그리고 기체가 아무 압력도 받지 않고 진공으로 들어가므로 일도 없습니다.&lt;/p&gt;

&lt;h4&gt;열역학 제2법칙은&lt;/h4&gt;

&lt;p&gt;에너지가 흐르는 방향을 설명하는 법칙입니다. 고립계에서 총 엔트로피(무질서도)의 변화는 항상 증가하거나 일정하며 절대로 감소하지 않습니다. 에너지 전달에는 방향이 있다는 것입니다. 즉 자연계에서 일어나는 모든 과정들은 가역과정이 아니라는 것입니다. 열역학 제2법칙에 따르면 엔트로피의 변화는 항상 0보다 큽니다. 열역학 제 1법칙은 에너지가 보존된다는 것을 나타냅니다. 그러나 에너지는 보존되지만, 자연계에서 실제로 일어나지 않는 많은 과정들이 있습니다. 예를 들어, 차가운 물체에 뜨거운 물체를 접촉시키면 뜨거운 물체에서 차가운 물체로는 열이 전달되지만, 반대의 과정은 자발적으로 일어나지 않습니다. 만약 열이 차가운 물체에서 흘러 나와 뜨거운 물체로 흘러 들어간다고 하면 에너지는 보존되어 열역학 제 1법칙은 만족합니다. 그러나 자연현상에서 이러한 일은 일어나지 않습니다. 이러한 비가역성을 설명하기 위해 19세기 후반의 과학자들은 열역학 제 2법칙이라는 새로운 원리를 발표하였습니다. 이 법칙으로 자연계에서 일어나지 않는 과정이 어떤 것들인가에 대한 설명이 가능해졌습니다. 열역학 제2법칙은 독일의 이론 물리학자인 클라우지우스가 처음 수학적으로 표현하였고, 얼마 후 켈빈-플랑크가 설명하였습니다. 열역학 제1법칙이 과정 전과 후의 에너지를 양적(量的)으로 규제하고 있는 데 비하여, 제2법칙은 에너지가 흐르는 방향을 규제하는 성격을 띠고 있습니다. 즉 에너지의 흐름은 엔트로피가 증가하는 방향으로 흐른다는 것입니다. 따라서 이 법칙에 따르면, 하나의 열원에서 열을 받아 이것을 일로 바꾸되 그외 어떤 외부의 변화도 일으키지 않는 열기관인 제2종 영구기관의 제작은 불가능하다고 할 수 있습니다. 제2종 영구기관은 100%열을 받아서 100%운동에너지로 바꿀 수 있는 기관입니다. 그렇지만 열역학 제2법칙에 따르면 제2종 영구기관의 제작은 불가능합니다. 한편, 물체의 상태만으로 결정되는 엔트로피라는 양을 정의하고, 이것으로 제2법칙에 대해, &#39;열의 출입이 차단된 고립계에서는 엔트로피가 감소하는 변화가 일어나지 않고, 항상 엔트로피가 증가하는 방향으로 변하며, 결국에는 엔트로피가 극대값을 가지는 평형상태에 도달한다&#39;고 할 수 있습니다. 즉, 에너지는 자유로이 형태를 변환시킬 수 있지만 그 때마다 반드시 에너지가 갖고 있었던 능력인 포텐셜(potential)이 사라집니다. 일반적으로 에너지를 변환시킬 때마다 엔트로피가 발생합니다. 그 결과 엔트로피의 총량은 증가하게 되며 에너지의 가치(potential)는 점점 줄어들게 됩니다.&lt;/p&gt;

&lt;h4&gt;열역학 제3법칙은&lt;/h4&gt;

&lt;p&gt;절대영도에서의 엔트로피에 관한 법칙으로 네른스트의 열정리라고도 합니다. 열역학과정에서의 엔트로피의 변화 ΔS는 절대온도 T가 0으로 접근할 때 일정한 값을 갖고, 그 계는 가장 낮은 상태의 에너지를 갖게 된다는 법칙입니다. 이 법칙에 의하면 절대영도에서 열용량은 0이 됩니다. 1906년 W. H. 네른스트는 열역학과정에서의 엔트로피의 변화 ΔS는 절대온도 T가 0에 접근함 따라 0이 된다(즉, T → 0의 극한에서 ΔS → 0)고 주장했습니다. 계의 엔트로피는 압력, 부피, 자기장 등 외부 조건과는 관계없이 온도가 0에 접근하게 되면 0이 됩니다. 그러면서 계가 크든 작든지 간에 하나의 가장 낮은 에너지 상태를 갖습니다. 만약 가장 낮은 준위가 3배로 축퇴(縮退, degeneracy)되어 있다면, 절대영도(0 K)에서 허용한 상태수는 3이므로, 엔트로피 S = k ln3로 표시할 수 있습니다. 따라서 제3법칙은 때로는 &#39;0&#39;이라는 숫자 대신에 &#39;어떤 상수&#39;로 표현해야 합니다. 이 법칙에 의하면 열용량은 절대영도에서 0이 되어야 합니다. 후에 더 나아가 M.플랑크는 온도(T)가 0K로 접근가게 됨에 따라 엔트로피 자신이 0이 된다(즉, T → 0에서 S → 0)고 주장했습니다. 이로써 온도(T)가 0K근처에서 비열이나 팽창률은 0이 된다는 결론이 나오므로, 유한 횟수의 과정의 경우에는 절대영도 상태까지 도달할 수 없습니다. 통계역학에서는 미시적 상태의 수를 W라 하면 엔트로피는 볼츠만의 원리에 의해 S=k ln W로 표시하는데 0K에서는 모든 계가 바닥상태[基底狀態]로 되며, 바닥상태는 축퇴되어있지 않다고 하면 한 가지 상태 W=1이 되어 S=0을 기대할 수 있습니다. 열역학 제3법칙을 간단하게 정리해서 말하면, 절대온도(T)가 0으로 접근(approach)할 때 계의 엔트로피(S)는 어떤 일정한 값(constant value)을 갖습니다.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Adding a post to github page</title>
   <link href="/2013/03/08/adding-a-post-to-github-page.html"/>
   <updated>2013-03-08T00:00:00+09:00</updated>
   <id>/2013/03/08/adding-a-post-to-github-page</id>
   <content type="html">&lt;h3&gt;Adding a post to github page&lt;/h3&gt;

&lt;h4&gt;Front-matter&lt;/h4&gt;

&lt;p&gt;프론트매터는 지킬에게 이 화일을 처리해야할 방법을 알려주는 일종의 메타데이타이다. 화일의 제일 앞에 위치해야 한다. 지킬은 front matter 블록으로 시작되는 파일만 처리한다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
layout: post  
title: Blogging Like a Hacker
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;각 블로그 포스트의 front matter에는 “title”과 “layout” 필드는 반드시 들어가야 한다. date는 화일 이름에 들어가니 필수는 아니다.&lt;/p&gt;

&lt;h4&gt;마크다운으로 포스트 작성하기&lt;/h4&gt;

&lt;p&gt;_posts 폴더에 모든 블로그 포스트 컨텐츠와 메타데이타가 있다. 지킬은 매우 스마트해서 이 폴더에 Markdown, HTML 과 다른 포맷을 섞어 넣을 수도 있다.&lt;/p&gt;

&lt;p&gt;블로그를 포스트하려면 마크다운 화일을 _posts 폴더에 떨어뜨리면 된다. 그러나, 포스트와 화일의 이름은 다음과 같은 이름 구조를 가져야한다:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;YYYY-MM-DD-[POST SLUG].[FORMAT]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;예로, 2013년 9월 14일에 마크다운 포맷으로 “best-blog-platforms”(한글은 피해야 한다.)에 대한 포스트를 썼다면 다음과 같이 이름붙인다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;2013-10-15-best-blog-platforms.md&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;post slug는 포스트 이름의 URL 친화적인 형식을 말한다. 스페이스나 이상한 문자와 URL에서 보통 허용되지 않는 것을 쓰지말라는 것이다. 표준 관례는 모든 문자는 소문자, 스페이스 대신 -를, 비교적 짧은 slug를 사용하는 것을 포함한다.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Wisdom from Steve Jobs</title>
   <link href="/2013/02/10/wisdomjobs.html"/>
   <updated>2013-02-10T00:00:00+09:00</updated>
   <id>/2013/02/10/wisdomjobs</id>
   <content type="html">&lt;h3&gt;스티브 잡스 명언 베스트 52가지&lt;/h3&gt;

&lt;h4&gt;애플 이야기&lt;/h4&gt;

&lt;p&gt;“제가 많은 사람들에게 가장 자주 받는 질문중 하나는 사업가가 되고 싶어한다는 거에요. 그래서 저는 &quot;오 훌륭하군요. 당시의 아이디어는 어떤건가요? &quot; 그러면 그들은 아직 하나도 가지지 못했다고 말하지요. 그리고 나는 말해요. 아무래도 당신은 조수자리를 우선 구하고 나서 당신이 정말로 모든 열정을 다 받칠수 있는 아이디어를 찾으시게 좋을겁니다. 왜냐하면 열정이 일에는 매우 중요하기 때문입니다. 성공 적인 사업가와 그렇지 못한 사업가의 차이는 참을성에 있기 때문입니다.  당신은 당신의 모든 부분을 사업에 헌신해야합니다. 사업에는 매우 힘든시간이 있고 대부분의 사람들은 포기합니다. 나는 그들을 비난하지 않아요. 그것은 정말로 힘든일이고 당신의 삶을 다 소모 시켜버리거든요. 만약에 당신이 가족이 있는 상태에서 사업을 시작했다면 어떻게 그것을 감당할 수 있을지 모르겠습니다. 왜냐하면 하루에 열여덟시간을 일하고 일주일에 7일을 일해야하 하기 때문입니다. 만약에 당신에 열정을 가지고 있지 않다면 당신은 살아남을 수 없습니다. 당신은 곧 포기하고 말것입니다. 당신이 열정을 쏟아 부을 수 있는 아이디어나 무엇인가를 바로잡고 싶은 문제들을 가지고 있어야 합니다. 그렇지 않는다면 끈기있게 메달릴 수 없습니다. 여기에서부터 승리의 반이 결정됩니다.&quot; (1995년 컴퓨터월드 스미스소니언 시상 인터뷰중에)&lt;/p&gt;

&lt;p&gt;애플은 너무 많은 잘못된 일에 열심이었습니다. 나는 애플에서 놀라운 능력을 가진 사람을 만났습니다. 애플에는 뛰어난 사람들이 많습니다. 하지만 그들은 잘못된 일을 하고 있었습니다. 왜냐하면 계획을 잘못 세웠기 때문입니다.                                                                     (1997년 보스턴 맥 월드 중에서)&lt;/p&gt;

&lt;p&gt;&quot;우리는 인간입니다. 우리는 실수를 합니다. 우리는 실수를 빨리 알아내죠. 바로 그것이 우리가 세상에서 고객들에게 가장 사랑받는 최고의 회사가 된 이유입니다.&quot;&lt;/p&gt;

&lt;p&gt;(아이폰4 기자 회견장에서)&lt;/p&gt;

&lt;p&gt; “애플의 핵심은 놀라울 정도로 상호협력적인 회사라는 겁니다. 애플에 위원회가 몇 개일 것 같습니까? 하나도 없습니다. 우리는 지금 막 새로 시작하는 회사와 비슷해요. 우리는 지구에서 가장 큰 신생 회사입니다. 우리는 매일 아침 만나서 3시간 동안 사업 전체에 대해서 이야기를 나눠요. 우리는 인력들을 어떻게 분배해야 최고의 팀이 구성되는지 알고 있습니다. 내가 하는 일은 매일 사람들을 만나서 이야기하는 겁니다. 위대한 사람들을 얻으려면 그들이 위대한 아이디어를 가질 수 있도록 도와줘야 해요. 나 역시 아이디어를 제공하죠. 그런 일을 하지 않는다면 내가 왜 여기 애플에 있겠습니까?”&lt;/p&gt;

&lt;p&gt;(2010년 D8 컨퍼런스에서)&lt;/p&gt;

&lt;p&gt;“나는 절대로 그 두 가지(예술과 과학)가 별개라고 생각하지 않습니다. 레오나르도 다빈치는 위대한 예술가이자 위대한 과학자였습니다. 미켈란젤로는 채석장에서 돌을 자르는 방법에 대해 엄청난 지식을 보유하고 있었습니다. 내가 아는 가장 뛰어난 컴퓨터 과학자들은 모두 음악가이기도 합니다. 어떤 사람이 다른 사람보다 더 뛰어난 실력을 가진 사람이 있겠죠. 하지만 그들 모두는 음악을 인생의 중요한 일부라고 생각합니다. 최고의 인재들 스스로를 갈라진 나무의 한쪽 가지로만 보지 않습니다. 나는 그렇게 볼수가 없습니다.&lt;/p&gt;

&lt;p&gt;(Steve Jobs at 44, Michael Krantz, TIME, 1999년 10월 10일 )&lt;/p&gt;

&lt;p&gt;우리의 사업에서 혼자서는 더이상 할 수 있는 일이 없습니다. 이제는 팀을 만들어야 합니다. 당신은 팀의 업무에 대해서 성실한 책임감을 가져야 합니다. 모든 사람이 그들이 할 수 있는 최고의 일을 할 수 있도록 해야 합니다.&lt;/p&gt;

&lt;p&gt;(1995년 컴퓨터 월드 스미스 소니언 인터뷰중에서 )&lt;/p&gt;

&lt;p&gt;“혁신은 복도에서도 즉시 미팅을 열거나 새로운 아이디어가 떠오를 때나 문제의 해결책을 찾아을 때 밤늦은 10:30분에도 전화통화를 하는 사람들에게 나옵니다. 세상에서 가장 멋진 아이디어를 떠올렸다고 생각하는 사람이 다른사람으로부터 아이디어에 대한 의견을 듣고 싶어서 특별회의같은걸 열 수 있어야 하죠”&lt;/p&gt;

&lt;p&gt;(2004년 비즈니스 위크)&lt;/p&gt;

&lt;p&gt;“나의 일은 개발자들을 위한 공간을 마련하고, 조직의 잡다한 일들을 처리하고 개발자들이 아무것에도 방해받지 않도록 하는 것입니다. “&lt;/p&gt;

&lt;p&gt;(1984년 맥월드 창간호에서)&lt;/p&gt;

&lt;p&gt;&quot;자.. 그럼 애플의 문제가 뭔지 한번 이야기해봅시다.&quot; 잡스가 말하자 몇몇이 우물쭈물 거린다. 스티브 잡스는 갑자기 큰소리로 &quot;문제는 제품입니다. 그런데 제품에 무엇이 잘못된겁니까?&quot; 다시 중역들이 우물쭈물 거리자 잡스는 그들의 말을 자르고는 외쳤다.&lt;/p&gt;

&lt;p&gt;&quot;제품이 엉터리라구! 더이상 사람들은 애플제품에 전혀 끌리지 않는다구!&quot;&lt;/p&gt;

&lt;p&gt;(2006년 비즈니스 위크중에서)&lt;/p&gt;

&lt;p&gt;“디자인은 참 재미있는 단어입니다. 어떤 사람들은 디자인을 단순히 제품의 외형 정도로만 생각합니다. 하지만 좀 더 깊이 들어가면 사실은 제품이 어떻게 작동하느냐를 의미하는 것이죠. 맥의 디자인은 단순히 외형만을 뜻하는 게 아닙니다. 물론 외형을 포함하기는 하지만 가장 중요한 것은 작동 방식입니다. 정말로 디자인을 잘하고 싶다면 여러분은 이것을 확실히 이해하고 있어야 합니다. 즉 제품의 본질에 완벽하게 통달해야만 합니다. 겉핥기가 아니라 완벽하게 제품을 이해하기 위해서는 열정적으로 헌신을 다해야만 합니다. 하지만 대부분의 사람들은 그런 일에 많은 시간을 들이지 않지요.“&lt;/p&gt;

&lt;p&gt;(1996년 와이어드 인터뷰에서 )&lt;/p&gt;

&lt;p&gt;우리는 많은 실수들을 하게 됩니다. 그것이 바로 인생입니다. 하지만 그러한 실수들은 결국 새로워지고 창조적이게 됩니다.
(1989년 INC의 인터뷰에서)&lt;/p&gt;

&lt;p&gt;“우리가족은 원하는 세탁기가 무엇인지를 얘기하면서 기간을 보낸적이 있습니다. 우리는 디자인에 대한 많은 이야기를 했지만 가족들이 중요시여기는 것들도 고려해야 했습니다. 세탁을 하는데 하신간만에 끝내는 세탁기와 한시간 반이 소요되는 세탁기중에 어느것이 좋은가? 옷이 부드럽고 오래가도록 하는 세탁기를 선택해야 하는가? 물 사용양은 괜찮은가? 우리는 2주동안 매일 저녁에 테이블에 앉아서 이야기를 나눴습니다. 우리는 오랜 시간 동안 세탁기에 대해서 토론을 했지요.&lt;/p&gt;

&lt;p&gt;(1996년 와이어드 인터뷰에서)&lt;/p&gt;

&lt;p&gt;“누가 PC 보드의 모양까지 신경쓰나요? 잘 작동하는게 중요하지 아무도 PC보드안을 꺼내보지 않아요.”&lt;/p&gt;

&lt;p&gt;이에 스티브 잡스는 자신이 본다면서 다음과 같이 말했다.&lt;/p&gt;

&lt;p&gt;“내가 봅니다. 비록 케이스안에 있다고 할지라도 나는 그것이 가능한 아름다워야한다고 생각해. 위대한 목수는 아무도 보지 않는다고 해서 장롱 뒷면에 형편없는 나무를 쓰지 않습니다.!”&lt;/p&gt;

&lt;p&gt;(PC Board Esthetics, Andy Hertzfeld, FOLKLORE)&lt;/p&gt;

&lt;p&gt;우리는 우리의 고객들을 사랑합니다. 정말 사랑합니다. 우리는 그들을 즐겁고 놀래키고 싶습니다. 그러기 위해서 우리는 정말  쉴틈없이 열심히 일하고있습니다.&lt;/p&gt;

&lt;p&gt;(2010년 아이폰4 기자회견장에서)&lt;/p&gt;

&lt;p&gt;“폴라로이드의 에드윈 랜드 박사는 이렇게 말한 적이 있습니다. “나는 폴라로이드의 예술과 과학의 교차점에 서길 바랍니다..” 저는 그 말을 단 한번도 잊은 적이 없습니다. 랜드 박사의 말이 충분히 가능한 일이고 많은 사람들이 이를 시도해왔다고 생각합니다. “&lt;/p&gt;

&lt;p&gt;(Steve Jobs at 44, Michael Krantz, TIME, 1999년 10월 10일 )&lt;/p&gt;

&lt;p&gt;“우리는 마이크로소프트와 플랫폼 전쟁을 펼쳤다고 생각하지 않아요. 아마 그래서 우리가 패한거겠죠 “&lt;/p&gt;

&lt;p&gt;(D8 컨퍼런스에서 스티브 잡스)&lt;/p&gt;

&lt;p&gt;“저는 그게 무슨 뜻인지 모르겠습니다. 내가 카니발이라도 운영한답니까? 우리가 애플에서 하는일은 매우 간단합니다. 우리는 제품을 발명합니다. 우리는 세상에서 가장 훌륭한 개인용 컴퓨터와 몇 개의 최고 소프트웨어를 만듭니다. 최고의 휴대용 MP3/뮤직 플레이어도 만들었죠. 그리고 우리는 이제 세계 최고의 온라인 음악 스토어를 만들었습니다. 우리는 그냥 제품을 만들뿐입니다. 나는 흥행주(impresario)가 무슨 의미인지 모르겠습니다. 우리는 제품을 만들고 이를 세상에 내놓으면 사람들은 그것을 사용합니다. “&lt;/p&gt;

&lt;p&gt;(타임지 인터뷰에서 월스트리트 저널이 애플을 디지털 흥행주라고 지칭했다면서 이에 대한 소감을 물어보자 )&lt;/p&gt;

&lt;p&gt;내가 최고 잘하는 것은 새로운 혁신적인 제품을 만드는 것입니다. 그것이 바로 내가 즐기는 것입니다. 나는 재능있는 소규모팀과 일하는 것을 잘하고 즐깁니다. 그런 방법으로 나는 애플2와 매킨토시를 만들었습니다. “&lt;/p&gt;

&lt;p&gt;(1985년 뉴스 위크에서)&lt;/p&gt;

&lt;p&gt;“우리는 이런 역사를 가지고 있습니다. 3.5인치 플로피를 우리가 대중화시켰고 최초의 아이맥에서는 플로피를 제거했습니다. 우리는 직렬과 병렬포트를 없애기도 했습니다. 여러분은 아이맥에서 USB를 처음 보았을 겁니다. 우리는 맥북에어에서 옵티컬 드라이브를 최초로 버렸습니다. 우리가 이런일을 할 때 사람들은 우리가 미쳤다고 합니다. “&lt;/p&gt;

&lt;p&gt;(2010년 D8 컨퍼런스에서)&lt;/p&gt;

&lt;p&gt;“마이크로 소프트가 맥을 카피할 수 있었던 것은 맥이 발전을 못했기 때문입니다. 맥은 지난 10년간 아무런 변화가 없었습니다. 대략 10% 정도 변했을뿐이죠. 애플은 종이 호랑이가 전락해 버렸습니다. 마이크로소프트가 애플을 베끼는데 10년이 걸린것은 놀라운 일입니다. 유감스럽게도 애플은 동정할 가치가 없어요. 그들은 연구개발비로 수억달러를 썼습니다. 하지만 결과물들이 없습니다. 그들은 오리지널 맥 이후로 새로운 혁신을 만들어내지 못하고 있습니다.“&lt;/p&gt;

&lt;p&gt;(1994년 롤링스톤과의 인터뷰에서)&lt;/p&gt;

&lt;p&gt;“음악이 아이팟의 중심이 되지 않는 날을 상상하기 힘듭니다. 아이팟은 매우 오래, 오래, 오래, 오래 음악으로 남을겁니다. 음악이 정말 중요한 시기에 성장기를 보낸 저는 매우 운이 좋습니다. 저의 배경때문이 아니라 음악은 정말로 자라나는 아이들에게 중요합니다. 음악은 정말로 세상을 바꾸었습니다. 한동안 음악에 대한 중요성이 빛을 바랬지만 애플이 음악을 의미있는 방식으로 사람들의 삶에 되돌려 놓았습니다. 음악은 우리안의 깊은 곳에 있지만 음악을 듣지 않아도 하루, 한주, 한달, 일년동안 살수 있습니다. 아이포드는 수천만명의 사람들을 변화시켰습니다. 그것이 저를 정말 행복하게 만듭니다. 왜냐하면 음악은 영혼에 좋은 거잖아요.“&lt;/p&gt;

&lt;p&gt;(2006년 뉴스위크에서)&lt;/p&gt;

&lt;p&gt;“그것은 마치 모든 사람이 입술을 가졌다고 해서 당신은 애인과 키스하고 싶어하지 않는 것과 같습니다. 말이 안됩니다. “
(2006년 뉴스위크와의 인터뷰에서 아이포드가 엘리자베스 여왕이나 딕 체니도 아이팟을 쓸정도로 대중적인데 어떻게 쿨하다고 할 수 있냐고 질문을 받은 스티브잡스의 답변)&lt;/p&gt;

&lt;p&gt;““나는 퍽이 있는 곳으로 가지지 않고, 퍽이 향하게 곳으로 간다.”&lt;/p&gt;

&lt;p&gt;(아이폰을 발표하는날 웨인 그레이츠키의 말을 이용하면서)&lt;/p&gt;

&lt;p&gt;“For the loser now  오늘의 패자가&lt;/p&gt;

&lt;p&gt;Will be later to win  내일의 승자가 될거야&lt;/p&gt;

&lt;p&gt;For the times they are a-ching 시대가 변하고 있으니까&lt;/p&gt;

&lt;p&gt;(1984년 맥 발표회에서 밥딜런의 노래가사를 인용함)&lt;/p&gt;

&lt;p&gt;“오늘은 내가 2년 반동안 기다렸던 날입니다. 때로는 혁명적인 제품이 모든 것을 바꾸어 놓는 순간이 있습니다. 애플은 그래왔습니다. 한번이라도 그런 일을 하게 되면 정말 행운 일겁니다. 그러면에서 애플은 매우 운이 좋습니다. 우리는 세상을 변화시킨 몇가지 제품을 내놓았거든요. 1984년 매킨토시를 발표하였고 그것은 애플뿐만 아니라 컴퓨터 산업전체를 바꾸어 놓았습니다. 2001년에는 아이팟을 소개하였고 음악을 듣는 방법뿐만 아니라 전체 음악산업 전체를 뒤흔들어 놓았습니다. 그리고 오늘 우리는 세번째로 혁명적인 새로운 제품을 소개하려고 합니다. “&lt;/p&gt;

&lt;p&gt;(2007년 아이폰 발표회에서)&lt;/p&gt;

&lt;p&gt;영화산업에서 의미있는 브랜드는 디즈니와 스티브 스필버그 단 두가지 뿐입니다. 우리는 세번째 브랜드로써 픽사를 세우고자 합니다. 성공적인 브랜드는 소비자들의 신뢰를 반영합니다. 소비자의 신뢰는 그 브랜드의 제품에 대해서 긍정적인 경험들이 오랫동안 축적됨으로써 만들어질 수 있습니다. 예를 들면 부모들은  디즈니의 브랜드가 붙은 만화에 대해서는 가족들이 보기에 적절하고 만족할 수 있는 영화라고 신뢰를 합니다. 이는 디즈니가 만든 영화들이 모두가 인정하는 훌륭한 작품들이었기 때문입니다.  이러한 신뢰는 부모와 디즈니에 이익을 가져다 줍니다. 부모들은 보다 쉽게 가족이 같이 즐길 수 있는 놀이를 결정할 수 있고 디즈니는 좀 더 쉽고 확실하게 그들의 새로운 영화에 관객들을 불러 모을 수 있기 때문입니다. 시간이 흐르면서 픽사도 디즈니와 같은 수준의 브랜드로 성장하기를 바랍니다. 픽사가 이러한 신뢰감을 얻기 위해서는 우선 소비자들도 픽사가 영화를 만들고 있다는 것을 알아야 합니다&lt;/p&gt;

&lt;p&gt;(1997년 픽사 연차보고서)&lt;/p&gt;

&lt;p&gt;“시제품으로 만든 레이저 프린터에서 처음으로 종이가 인쇄되던 모습을 기억합니다. 그것은 캐논으로부터 만들어진 첨단 프린터와 어도비로부터 포스트스크립트 기술을 통합시킨 것이었죠. 정말 놀라운 기술의 결합체였습니다. 종이가 인쇄되어 나오고 내가 그 종이를 보자 그것은 정말 아름다웠습니다. 나는 속으로 생각했죠. 이것은 정말 팔린다. 왜냐하면 우리는 누군가에게 이 기계에 대해서 어느것도 설명할 필요가 없었어요. 우리가 해야할일은 인쇄된 종이를 보여준 후에 이것을 원하느냐고 묻는것지요. 만약에 이런 인쇄물을 원한다면 이 기기를 사라고 하면 됩니다. 이것이 바로 우리의 마케팅 전략입니다&lt;/p&gt;

&lt;p&gt;(1999년 타임지와의 인터뷰에서)&lt;/p&gt;

&lt;p&gt;“세계 최고의 브랜드 다섯가지는 무엇이 있을까요? 만약 전문가들에게 이 질문을 한다면 모든 대답에는 나이키, 코카콜라, 디즈니가 들어가 있을겁니다. 그리고 애플도 리스트에 올라가 있을 겁니다. 애플은 세계최고의 브랜드를 가지고 있었지만 우리는 지난 몇 년간 브랜드에 깊은 관심을 기울이지 않았습니다. 이제 여러분들은 애플이 변하기 시작하는 모습을 지켜보게 될 것입니다. “&lt;/p&gt;

&lt;p&gt;(1997년 보스턴 맥월드에서)&lt;/p&gt;

&lt;p&gt;&quot;위대한 제품은 기술적인 관점과 소비자의 관점 두가지를 합치는데 있습니다.  당신에게는 두가지가 필요합니다. 당신은 고객이 원하는 것이 무엇인지를 물어서 그들에게 제품을 만들어 줄수는 없습니다.&lt;br/&gt;
만약에 고객에 물어서 제품을 만들었다고 칩시다. 그순간 소비자들은 뭔가 새로운 것을 원하게 될것입니다. &quot;&lt;/p&gt;

&lt;p&gt;(1989년 INC와의 인터뷰)&lt;/p&gt;

&lt;p&gt;“여러분들이 애플 컴퓨터를 구입하기 위해서는 다르게 생각해야 합니다. 애플 컴퓨터를 구입한 사람은 다르게 생각합니다. 그들은 세상에서 창조적인 영혼들입니다. 그들은 단순히 일을 잘 하려는게 아니라 세상을 바꾸려는 사람들입니다. 그들은 자신들이 구할 수 있는 최고의 도구를 선택해서 세상을 바꾸려고 합니다. 우리는 바로 그런 사람들을 위해서 도구를 만듭니다. “
(1997년 보스턴 맥월드에서)&lt;/p&gt;

&lt;p&gt;여기 미친 광이들이 있다.&lt;/p&gt;

&lt;p&gt;사회부적응자, 반항아, 말썽장이,&lt;/p&gt;

&lt;p&gt;네모난 구멍속에 쑤셔넣은 둥근 못 같은 사람들&lt;/p&gt;

&lt;p&gt;세상을 다르게 보는 사람들&lt;/p&gt;

&lt;p&gt;그들은 규칙을 좋아하지 않는다.&lt;/p&gt;

&lt;p&gt;그리고 그들은 현재를 존중하지 않는다.&lt;/p&gt;

&lt;p&gt;당신은 그들의 말을 인용하거나,&lt;/p&gt;

&lt;p&gt;당신은 그들의 말에 동의하지 않을 수도 있다.&lt;/p&gt;

&lt;p&gt;당신은 그들을 찬양하거나 비난할 수 있다.&lt;/p&gt;

&lt;p&gt;모든 것이 당신의 자유지만 단한가지 당신은 그들을 무시할 수가 없다.&lt;/p&gt;

&lt;p&gt;왜냐하면 그들은 세상을 변화시켰기 때문이다.&lt;/p&gt;

&lt;p&gt;그들은 인류를 앞으로 이끌어 나간다.&lt;/p&gt;

&lt;p&gt;어떤 사람들은 그들을 미치광이로 보겠지만, 우리들은 그들이 천재라고 생각한다.&lt;/p&gt;

&lt;p&gt;왜냐하면 세상을 변화시킬 수 있다고 생각할 정도로 미친 사람들이야 말로 세상을 바꾸기 때문이다.&lt;/p&gt;

&lt;p&gt;(애플의 Think Different 광고중에서)&lt;/p&gt;

&lt;p&gt;여러분이 과거를 뒤돌아볼 수 있을 때, 그때 비로소 이 점들을 연결할 수 있습니다. 그러므로 현재라는 모든 점들이 당신의 미래와 어떻게든 이어질 것이라는 것을 믿어야만 합니다. 본능, 운명, 삶, 업보 등 그게 무엇이든 간에 점들이 결국 연결되어서 하나의 길을 만들 것이라는 것을 믿게 된다면, 여러분은 자신의 마음이 움직이는 대로 따르는 것에 자신감을 가지게 될 것입니다. 설사 자신의 마음을 따르는 것이 잘 닦여진 길로부터 벗어나게 할지라도 당신의 인생에 변화를 가져올 것입니다.”&lt;/p&gt;

&lt;p&gt;2005년 스탠포드 대학교 연설에서&lt;/p&gt;

&lt;p&gt;“창조라는 것은 그냥 여러 가지 요소를 하나로 연결하는 겁니다. 창조적인 사람에게 어떻게 그렇게 창조적으로 일할 수 있느냐고 묻는다면 그들은 죄책감을 느낄 겁니다. 왜냐하면 그들은 실제로 무엇을 한 것이 아니라 단지 뭔가를 본 것이기 때문입니다. 그것들은 시간이 지나면 더욱 명확해집니다. 그들의 창조성은 그들이 경험했던 것을 새로운 것으로 연결할 수 있을 때 생겨나는 겁니다. 그러한 능력은 그들이 다른 사람보다 많은 경험을 하고, 그들의 경험에 대해서 더 많이 생각하기 때문에 가능한 거지요.&lt;/p&gt;

&lt;p&gt;안타까운 사실은 능력이 부족하다는 겁니다. 컴퓨터 업계에서 일하는 대부분의 사람들은 다양한 경험을 가지지 못했습니다. 그래서 연결할 점들이 부족하기 떄문에 그들은 문제에 대한 폭넓은 관점으로 전체를 바라보지 못하고 그저 일차원적인 해결책만을 내놓을 뿐입니다. 인간의 경험에 대해 폭넓게 이해할수록 더 훌륭한 디자인을 만들 수 있게 됩니다.&lt;/p&gt;

&lt;p&gt;(1996년 와이와드와의 인터뷰에서)&lt;/p&gt;

&lt;p&gt;“여러분의 시간은 한정되어 있습니다. 그러니 다른 사람의 인생을 사느라고 시간을 낭비하지 마십시오. 다른 사람의 생각으로 만들어낸 규칙에 빠지지 마십시오. 그것은 다른 사람의 생각에서 나온 결론에 맞춰 사는 것과 같습니다. 다른 사람의 의견에 의해서 여러분 내면의 소리를 죽이지 마십시오. 가장 중요한 것은 여러분의 마음과 직관을 따르는 용기를 가지는 것입니다. 여러분의 마음과 직관은 이미 당신이 진정으로 무엇을 원하는지 알고 있습니다. 나머지는 모두 부차적인 것입니다.”&lt;/p&gt;

&lt;p&gt;(2005년 스탠포드 대학교 연설에서)&lt;/p&gt;

&lt;p&gt;&quot;내가 10살인가 11살 때쯤 에임스에 있는 나사 연구소에서 처음으로 컴퓨터를 보았어요. 그것은 진짜 컴퓨터는 아니었고 컴퓨터와 선으로 연결된 단발기였죠. 어쨌든 나는 그것과 사랑에 빠졌어요. 내가 처음으로 데스크탑 컴퓨터를 본 것은 9100A라 불리우는 휴렛 팩커드의 제품입니다. 그것은 내가 생각하기에 ABL과 베이직이 돌아가는 세계 최초의 데스크탑 컴퓨터였어요. 그리고 나는 그것에 사랑에 빠졌죠. &quot;&lt;/p&gt;

&lt;p&gt;(스티브 잡스 스미스소니언 협회 인터뷰 중에서)&lt;/p&gt;

&lt;p&gt;&quot;나는 항상 애플과 연결되어 있습니다 내 인생의 실과 애플의 실은 서로 직물처럼 엮어있으면 좋겠습니다. 애플에 내가 몇 년간 없을때도 있을 겁니다. 하지만 나는 돌아 올겁니다. &quot;&lt;/p&gt;

&lt;p&gt;(스티브 잡스 1985년 플레이 보이와의 인터뷰 중에서)&lt;/p&gt;

&lt;p&gt;&quot;애플의 존재를 설명해주는 제품이 하나라도 있다면 그것은 바로 아이팟입니다. 아이팟에는 애플의 놀라운 기술에 사용하기 쉬움 그리고 굉장히 멋진 디자인이 하나로 결합되어 있습니다. 우리가 항상 그래왔듯이 말이죠. 만약 누군가 애플이 왜 세상이 있느냐고 묻는다면 나는 좋은 예로 아이팟을 들어 올립겁니다.&lt;/p&gt;

&lt;p&gt;&quot;우리가 맥을 발표하기 일주일전이 생각나네요. 우리 모두는 컴퓨터가 맥처럼 바뀔것이라는 것을 알고 있었어요. 앞으로 컴퓨터가 맥처럼 바뀔지 안바뀔지에 대한 문제가 아니라 언제쯤 맥처럼 바뀌느냐가 문제였죠. 지금 이순간 그런 느낌이 듭니다. &quot;
(아이폰 발매전 월스트리트 저널과의 인터뷰 중에서)&lt;/p&gt;

&lt;p&gt;&quot;좋은 직원들은 이미 떠났을 것이라고 생각했습니다. 그런데 나는 애플에 정말 놀라운 사람들이 남아있다는 것을 알게됐어요 그래서 직원들에게 왜 아직까지 여기 남아 있으냐고 물었죠. 그런데 그들은 애플을 믿고 있다고 답하더구요. 우리는 애플이 추구하는 것을 사랑합니다.&quot;&lt;/p&gt;

&lt;p&gt;(스티브 잡스 D8: All Things Digital 컨퍼런스에서 )&lt;/p&gt;

&lt;p&gt;&quot;모든 핵심은 소프트웨어요. 사실 소프트웨어는 사용자 경험이죠.&quot;
                                                  (포춘 인터뷰 중에서)&lt;/p&gt;

&lt;p&gt;“우리는 단순한 기술 회사가 아닙니다. 애플은 그 이상입니다. 바로 기술과 휴머니티죠. 우리는 하드웨어와 소프트웨어 작업을 함께 합니다. 우리는 단순히 위대한 카메라 시스템을 만든게 아닙니다. 이것은 찍은 영상을 편집도 할 수 있습니다. 우리는 단지 전면부 카메라를 넣은게 아닙니다. 우리는 18개월이 넘는 동안 소프트웨어 작업을 병행했습니니다. 이것은 하나의 완결된 솔루션입니다. 그래서 우리 모두는 시스템 전문가가 될 필요가 없습니다. “&lt;/p&gt;

&lt;p&gt;2010년 WWDC 키노트 연설에서&lt;/p&gt;

&lt;p&gt;나의 일은 언제나 팀의 질적 수준을 최고로 유지하는 것에 있다고 생각하고 있습니다.&lt;/p&gt;

&lt;p&gt;(스티브 잡스 스미스소니언 협회 인터뷰 중에서)&lt;/p&gt;

&lt;p&gt;기술 업계 회사일지라도 제품 지향 문화가 필요합니다. 많은 회사들이 훌륭한 엔지니어와 똑똑한 사람들을 잔뜩 데리고 있습니다. 하지만 그것을 하나로 묶는 힘이 필요합니다.&lt;/p&gt;

&lt;p&gt;(스티브 잡스 2004년 비즈니스 위크 인터뷰중에서 )&lt;/p&gt;

&lt;p&gt;우리는 우주에 흔적을 남기기 위해서 여기에왔다. 그렇지 않다면 왜 우리가 여기에 있겠는가?&lt;/p&gt;

&lt;p&gt;(매킨토시 시절 스티브 잡스가 직원들에게 자주 했던 말이다.)&lt;/p&gt;

&lt;p&gt;우리는 권력이라고 생각하지 않습니다. 우리는 고객들이 놀라고 기뻐하는 혁신적인 제품을 만듭니다. 그러면 행복하고 충성스러운 고객들이 애플에게 힘을 실어주지요. 우리는 마음속으로 정말 위대하다고 생각하는 제품을 만들뿐이에요. 고객들이 우리가 사랑하는 만큼 우리 제품을 사랑해주기를 바라는 마음으로요. 그리고 지난 몇년간 이일을 참 잘해왔다고 생각해요.&lt;/p&gt;

&lt;p&gt;(스티브 잡스 포춘 2007년)&lt;/p&gt;

&lt;p&gt;아이팟 사업에는 분명한 후광효과가 있었습니다. 애플 제품을 한번도 사용하지 않은 많은 사람들이 처음으로 아이팟을 구입하고 있습니다. 그들은 아이팟을 사용하고는 이렇게 말해요. &quot;와우! 애플의 다른 제품은 어떨까? 그들은 애플이 만든 제품에 훨씬 호의적으로 변하게 되는거죠. 나는 후광효과가 아이폰에서도 일어나기를 바라고 있습니다. 어쩌면 더 많은 사람들이 처음으로 구입하는애플 제품이 아이폰이 될수도 있을겁니다.&lt;/p&gt;

&lt;p&gt;(2007년 월스트리트 저널 인터뷰)&lt;/p&gt;

&lt;p&gt;인간은 원래 창조적으로 태어납니다.  도구를 만든 사람은 절대로 가능하다고 생각하지도 못한 방식으로 인간은 도구를 사용하게 됩니다.&lt;/p&gt;

&lt;p&gt;(1989년 INC와의 인터뷰에서)&lt;/p&gt;

&lt;p&gt; (애플에 돌아 온 직후)내 인생에 그렇게 피곤했던 적이 없습니다. 나는 10시쯤에 귀가해서 바로 침대로 직행했죠. 그리고 아침 여섯시에 일어나서 샤워를 하고 회사로 갔습니다. 이 모든 게 아내덕분에 견딜 수 있었습니다. 그녀는 나를 지원해주는 한편 가장이 없는 집을 잘 보살펴 주었지요.&lt;/p&gt;

&lt;p&gt;(1998년 포춘 스티브 잡스)&lt;/p&gt;

&lt;p&gt;우리는 우리의 비전에 모든것을 걸었습니다. 우리는 남들을 따라하는 제품을 만드는 편보다는 낫다고 봅니다.  흉내내기는 다른 회사들이 하면됩니다.  우리에게는 언제나 다음의 꿈이있습니다.&lt;/p&gt;

&lt;p&gt;(1984년 매킨토시 발표회장에서)&lt;/p&gt;

&lt;p&gt;물량보다 품질이 중요합니다. 두개의 2루타보다 한개의 홈런이 더 중요해요
(2006년 비즈니스 위크 중에서)&lt;/p&gt;

&lt;p&gt;당신이 할 수 있는 최고의 물건을 만들려면 당신이 옳다고 생각할 때까지 멈춰서는 안됩니다. 당시의 머리가 무엇이라고 할지라도 사람들이 보여주기 직전에 당신의 가슴을 빠르게 뛰게 될것입니다.&lt;/p&gt;

&lt;p&gt;(1989년 INC의 인터뷰에서)&lt;/p&gt;

&lt;p&gt;여러분 모두가 저를 정말 묘한 기분이 들도록 합니다. 왜냐하면 나는 매일 세상에서 가장 뛰어난 재능을 가진 사람들과 함께 애플과 픽사에서 일합니다. 세상에서 가장 멋진 직업입니다. 이 일은 팀스포츠입니다.  애플은 팀스포츠입니다.&lt;/p&gt;

&lt;p&gt;Macworld San Francisco 2000-Steve Jobs Becomes iCEO of Apple&lt;/p&gt;

&lt;p&gt;신념을 잃지 마십시오.&lt;/p&gt;

&lt;p&gt;내가 계속 앞으로 전진 할 수 있도록 도와준 유일한 힘은 바로 내가 사랑하는 일을 했기 때문이라고 확신합니다. 여러분은 여러분이 사랑하는 것을 찾아야 합니다. 이것은 마치 사랑하는 연인을 찾는 것과 똑 같습니다. 여러분의 일은 여러분 인생의 큰 부분을 채우게 될 것입니다.&lt;/p&gt;

&lt;p&gt;그리고 진심으로 만족하는 유일한 방법은 여러분이 위대한 일을 하고 있다고 믿는 것입니다. 그리고 위대한 일을 하는 유일한 방법은 바로 여러분이 하는 일을 사랑하는 겁니다. 만약에 여러분이 사랑하는 일을 찾지 못했다면 계속 찾아보십시오. 안주하지 마세요 여러분이 진정으로 사랑하는 일을 찾게 되면 마음으로 하는 모든 일들이 늘 그렇듯이 여러분은 확실히 알 수 있게 될 것입니다.  위대한 관계가 모두 그렇듯이 일과 여러분의 관계는 시간이 흐르면서 더욱 좋아질 겁니다. 그러므로 여러분은 계속 찾아 보십시오. 안주하지 마세요.&lt;/p&gt;

&lt;p&gt;(2005년 스탠포드 대학교 연설중에서)&lt;/p&gt;

&lt;p&gt;추가&lt;/p&gt;

&lt;p&gt;“이제 하드웨어에서는 다른 제품보다 두 배 뛰어난 컴퓨터를 만드는 것이 힘들어졌습니다. 이미 많은 사람들이 컴퓨터를 만드는 방법을 알고 있어요. 운이 좋다면 1.33배라든지 1.5배 정도로 빠른 컴퓨터를 만들 수는 있겠지요. 하지만 그것마저도 6개월 정도면 모두에게 따라잡히고 말 것입니다. 하지만 소프트웨어라면 아직 가능성이 있습니다. “&lt;/p&gt;

&lt;p&gt;1994년 롤링스톤 인터뷰에서&lt;/p&gt;

&lt;p&gt;혁신이 리더와 모방자의 차이를 만들어냅니다.&lt;/p&gt;

&lt;p&gt;2007년 아이폰 발표회에서&lt;/p&gt;
</content>
 </entry>
 
 
</feed>